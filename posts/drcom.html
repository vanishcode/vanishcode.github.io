<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><link rel="preload" as="font" href="/_next/static/media/e4af272ccee01ff0-s.p.woff2" crossorigin="" type="font/woff2"/><link rel="stylesheet" href="/_next/static/css/9152c37d2d6aee8c.css" data-precedence="next"/><title>在任意 OpenWrt 设备上运行 EasyDrcom</title><meta name="description" content="一块心病的解决 ❤️"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="icon" href="/favicon.ico" type="image/x-icon" sizes="any"/><meta name="next-size-adjust"/><script src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js" noModule=""></script></head><body class="antialiased min-h-screen bg-white dark:bg-slate-950 text-slate-900 dark:text-slate-50 __className_52d07b"><script>!function(){try{var d=document.documentElement,c=d.classList;c.remove('light','dark');var e=localStorage.getItem('theme');if('system'===e||(!e&&true)){var t='(prefers-color-scheme: dark)',m=window.matchMedia(t);if(m.media!==t||m.matches){d.style.colorScheme = 'dark';c.add('dark')}else{d.style.colorScheme = 'light';c.add('light')}}else if(e){c.add(e|| '')}if(e==='light'||e==='dark')d.style.colorScheme=e}catch(e){}}()</script><div class="max-w-2xl mx-auto py-10 px-4"><header><div class="flex items-center justify-between"><button class="border rounded-md w-6 h-6 flex items-center justify-center"><span class="sr-only">Toggle mode</span><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-4 h-4"><path stroke-linecap="round" stroke-linejoin="round" d="M21.752 15.002A9.718 9.718 0 0118 15.75c-5.385 0-9.75-4.365-9.75-9.75 0-1.33.266-2.597.748-3.752A9.753 9.753 0 003 11.25C3 16.635 7.365 21 12.75 21a9.753 9.753 0 009.002-5.998z"></path></svg></button><nav class="ml-auto text-sm font-medium space-x-6"><a href="/">Home</a><a href="/about">About</a></nav></div></header><main><article class="py-6 prose dark:prose-invert"><h1 class="mb-2">在任意 OpenWrt 设备上运行 EasyDrcom</h1><p class="text-xl mt-0 text-slate-700 dark:text-slate-200">一块心病的解决 ❤️</p><hr class="my-4"/><p>“如何在任意刷写了 OpenWrt 的设备上运行 EasyDrcom” 一直是我的一个心病，因为大学期间搞了好多次，搞了好久，时间跨度将近两年也没解决这个问题。不过最近有时间，用了两天时间，终于研究得差不多了。</p>
<p>设备以 HG255D 为例</p>
<p>开发前要搭建 OpenWrt 交叉编译环境，按照网上教程就可以了，就是在 Ubuntu 上安装各种包。然后开始开发：</p>
<p>1.下载对应芯片的 SDK，里面包含了开发一个 OpenWrt 软件包所需要的所有东西。
比如 HG255D 是 rampis 厂家 rt3052 芯片，那么最新版 OpenWrt 对应的 SDK 链接就是 https://archive.openwrt.org/releases/21.02.0/targets/ramips/rt305x/openwrt-sdk-21.02.0-ramips-rt305x_gcc-8.4.0_musl.Linux-x86_64.tar.xz</p>
<p>OpenWrt 前几个版本差异有点大，而且还出了 LEDE 这样一个 fork，所以你路由里用的什么版本的固件，就要使用什么版本的 SDK，不然兼容性可能有问题。比如 21 的 SDK 编译的软件包在 14 的系统下很有可能是跑不了的。</p>
<p>2.解压 SDK，进入文件夹，首先要获取必要的包，运行 <code>./script/feeds update -a</code>，之后运行 <code>./script/feeds install -af</code> 这样就安装了所有的依赖。如果发生问题，要不是时区的问题，要么是梯子的问题，自行解决吧。</p>
<blockquote>
<p>其实有 docker 的话还能再简单一点：docker pull openwrtorg/sdk:ramips-rt305x-21.02.1</p>
</blockquote>
<p>3.在 package 目录下建立我们自己的包，首先建空文件夹命名为 easydrcom，然后创建一个 Makefile，内容如下：</p>
<pre><code class="language-Makefile">###############################################
#OpenWrt Makefile for easydrcom program
##############################################
include $(TOPDIR)/rules.mk
# Name and release number of this package
PKG_NAME:=easydrcom
PKG_RELEASE:=1
# This specifies the directory where we&#x27;re going to build the program.
# The root build directory, $(BUILD_DIR), is by default the build_mipsel
# directory in your OpenWrt SDK directory
PKG_BUILD_DIR := $(BUILD_DIR)/$(PKG_NAME)
include $(INCLUDE_DIR)/package.mk
# Specify package information for this program.
# The variables defined here should be self explanatory.
# If you are running Kamikaze, delete the DESCRIPTION
# variable below and uncomment the Kamikaze define
# directive for the description below
define Package/$(PKG_NAME)
	SECTION:=utils
	CATEGORY:=Utilities
	DEPENDS:=+libpcap +libpthread +libstdcpp
	TITLE:=$(PKG_NAME) -- drcom fro hitwh
endef
# Uncomment portion below for Kamikaze and delete DESCRIPTION variable above
define Package/$(PKG_NAME)/description
	free wireless at hitwh.
endef
# Specify what needs to be done to prepare for building the package.
# In our case, we need to copy the source files to the build directory.
# This is NOT the default.  The default uses the PKG_SOURCE_URL and the
# PKG_SOURCE which is not defined here to download the source from the web.
# In order to just build a simple program that we have just written, it is
# much easier to do it this way.
define Build/Prepare
	mkdir -p $(PKG_BUILD_DIR)
	$(CP) ./src/* $(PKG_BUILD_DIR)/
endef
# We do not need to define Build/Configure or Build/Compile directives
# The defaults are appropriate for compiling a simple program such as this one
# Specify where and how to install the program. Since we only have one file,
# the easydrcom executable, install it by copying it to the /bin directory on
# the router. The $(1) variable represents the root directory on the router running
# OpenWrt. The $(INSTALL_DIR) variable contains a command to prepare the install
# directory if it does not already exist.  Likewise $(INSTALL_BIN) contains the
# command to copy the binary file from its current location (in our case the build
# directory) to the install directory.
define Package/$(PKG_NAME)/install
	$(INSTALL_DIR) $(1)/bin
	$(INSTALL_BIN) $(PKG_BUILD_DIR)/$(PKG_NAME) $(1)/bin/
endef
# This line executes the necessary commands to compile our program.
# The above define directives specify all the information needed, but this
# line calls BuildPackage which in turn actually uses this information to build a package.
$(eval $(call BuildPackage,$(PKG_NAME)))
</code></pre>
<p>4.建立src文件夹，将 EasyDrcom 的代码复制进去，链接：https://github.com/coverxit/EasyDrcom/tree/master/EasyDrcom
这里需要修改一下，我们不用 boost，一是太老了，二是编译时候还需要额外引入 boost，没必要这样。</p>
<p>我们使用这个头文件，用一个文件就能解析 init 配置文件：https://github.com/benhoyt/inih</p>
<p>复制 https://github.com/benhoyt/inih/tree/master/cpp 下 INIReader.h 到 src 文件夹里</p>
<p>5.修改 main.cpp 为</p>
<pre><code class="language-cpp">/**
 * Copyright (C) 2014 Shindo
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include &lt;thread&gt;
#include &lt;mutex&gt;
#include &lt;condition_variable&gt;
#include &lt;chrono&gt;

#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;stdexcept&gt;
#include &lt;functional&gt;
#include &lt;ctime&gt;
#include &lt;fstream&gt;
#include &lt;sstream&gt;
#include &lt;cctype&gt;

#if defined(__APPLE__) || defined(LINUX) || defined(linux)
#include &lt;sys/types.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;net/ethernet.h&gt;
#endif

#include &quot;INIReader.h&quot;
#include &quot;easy_drcom_exception.hpp&quot;

struct easy_drcom_config {
    struct config_general {
        int mode;
        std::string username;
        std::string password;
        bool auto_online;
        bool auto_redial;
    } general;
    
    struct config_remote {
        std::string ip;
        uint32_t port;
        
        bool use_broadcast;
        std::vector&lt;uint8_t&gt; mac;
    } remote;
    
    struct config_local {
        std::string nic;
        std::string hostname;
        std::string kernel_version;
        
        std::string ip;
        std::vector&lt;uint8_t&gt; mac;
        
        uint32_t eap_timeout;
        uint32_t udp_timeout;
    } local;
    
    struct config_fake {
        bool enable;
        std::vector&lt;uint8_t&gt; mac;
        std::string username;
        std::string password;
    } fake;
} conf;

// Log Config
#define EASYDRCOM_DEBUG
//#define EASYDRCOM_PRINT_DBG_ON_SCREEN
#include &quot;log.hpp&quot;

#define MAX_RETRY_TIME 2
#include &quot;utils.hpp&quot;
#include &quot;drcom_dealer.hpp&quot;
#include &quot;eap_dealer.hpp&quot;

#define VERSION &quot;v0.9&quot;

#if defined (WIN32)
#define VERSION (MAJOR_VERSION &quot; for Windows&quot;)
#elif defined __APPLE__
#define VERSION (MAJOR_VERSION &quot; for Mac OSX&quot;)
#elif defined (OPENWRT)
#define VERSION (MAJOR_VERSION &quot; for OpenWrt (mips AR7xxx/9xxx)&quot;)
#elif defined (LINUX)
#define VERSION (MAJOR_VERSION &quot; for Linux&quot;)
#endif

int read_config(std::string path)
{
    INIReader pt(path);

    try {
        conf.general.mode = pt.GetInteger(&quot;General&quot;, &quot;Mode&quot;, 0);
        conf.general.username = pt.Get(&quot;General&quot;, &quot;UserName&quot;, &quot;&quot;);
        conf.general.password = pt.Get(&quot;General&quot;, &quot;PassWord&quot;, &quot;&quot;);
        conf.local.nic = pt.Get(&quot;Local&quot;, &quot;NIC&quot;, &quot;&quot;);
    }
    catch (std::exception&amp; e) {
        SYS_LOG_ERR(&quot;Failed to read &#x27;&quot; &lt;&lt; path &lt;&lt; &quot;&#x27; - &quot; &lt;&lt; e.what() &lt;&lt; std::endl);
        return EBADF;
    }
    
    conf.general.auto_online = pt.GetBoolean(&quot;General&quot;, &quot;AutoOnline&quot;, true);
    conf.general.auto_redial = pt.GetBoolean(&quot;General&quot;, &quot;AutoRedial&quot;, true);
    
    conf.remote.ip = pt.Get(&quot;Remote&quot;, &quot;IP&quot;, &quot;172.25.8.4&quot;);
    conf.remote.port = pt.GetBoolean(&quot;Remote&quot;, &quot;Port&quot;, 61440);
    conf.remote.use_broadcast = pt.GetBoolean(&quot;Remote&quot;, &quot;UseBroadcast&quot;, true);
    
    if (!conf.remote.use_broadcast)
        conf.remote.mac = str_mac_to_vec(pt.Get(&quot;Remote&quot;,&quot;MAC&quot;, &quot;00:1a:a9:c3:3a:59&quot;));
    
    conf.local.hostname = pt.Get(&quot;Local&quot;, &quot;HostName&quot;, &quot;EasyDrcom for HITwh&quot;);
    conf.local.kernel_version = pt.Get(&quot;Local&quot;,&quot;KernelVersion&quot;, &quot;0.7&quot;);
    
    conf.local.eap_timeout = pt.GetInteger(&quot;Local&quot;, &quot;EAPTimeout&quot;, 1000);
    conf.local.udp_timeout = pt.GetInteger(&quot;Local&quot;, &quot;UDPTimeout&quot;, 2000);
    
    conf.fake.enable = pt.GetInteger(&quot;Fake&quot;, &quot;Enable&quot;, 0);
    
    SYS_LOG_DBG(&quot;General.UserName = &quot; &lt;&lt; conf.general.username &lt;&lt; &quot;, General.PassWord = &quot; &lt;&lt; conf.general.password &lt;&lt; &quot;, General.Mode = &quot; &lt;&lt; conf.general.mode &lt;&lt; std::endl);
    SYS_LOG_DBG(&quot;General.AutoOnline = &quot; &lt;&lt; (conf.general.auto_online ? &quot;True&quot; : &quot;False&quot;) &lt;&lt; &quot;, General.AutoRedial = &quot; &lt;&lt; (conf.general.auto_redial ? &quot;True&quot; : &quot;False&quot; ) &lt;&lt; std::endl);
    SYS_LOG_DBG(&quot;Remote.IP:Port = &quot; &lt;&lt; conf.remote.ip &lt;&lt; &quot;:&quot; &lt;&lt; conf.remote.port &lt;&lt; &quot;, Remote.UseBroadcast = &quot; &lt;&lt; (conf.remote.use_broadcast ? &quot;True&quot; : &quot;False&quot; ) &lt;&lt; std::endl);
    if (!conf.remote.use_broadcast) SYS_LOG_DBG(&quot;Remote.MAC = &quot; &lt;&lt; hex_to_str(&amp;conf.remote.mac[0], 6, &#x27;:&#x27;) &lt;&lt; std::endl);
    SYS_LOG_DBG(&quot;Local.NIC = &quot; &lt;&lt; conf.local.nic &lt;&lt; &quot;, Local.HostName = &quot; &lt;&lt; conf.local.hostname &lt;&lt; &quot;, Local.KernelVersion = &quot; &lt;&lt; conf.local.kernel_version &lt;&lt; std::endl);
    SYS_LOG_DBG(&quot;Local.EAPTimeout = &quot; &lt;&lt; conf.local.eap_timeout &lt;&lt; &quot;, Local.UDPTimeout = &quot; &lt;&lt; conf.local.udp_timeout &lt;&lt; std::endl);
    
    try {
        conf.local.ip = get_ip_address(conf.local.nic);
        conf.local.mac = get_mac_address(conf.local.nic);
        
        SYS_LOG_INFO(&quot;Fetch NIC IP &amp; MAC successfully.&quot; &lt;&lt; std::endl);
        SYS_LOG_INFO(&quot;Local.IP = &quot; &lt;&lt; conf.local.ip &lt;&lt; &quot;, Local.MAC = &quot; &lt;&lt; hex_to_str(&amp;conf.local.mac[0], 6, &#x27;:&#x27;) &lt;&lt; std::endl);
    }
    catch (std::exception&amp; e) {
        SYS_LOG_ERR(&quot;Failed to fetch NIC info - &quot; &lt;&lt; e.what() &lt;&lt; std::endl);
        return EBADF;
    }
    
    if (conf.fake.enable) // fake user
    {
        try {
            conf.fake.mac = str_mac_to_vec(pt.Get(&quot;Fake&quot;, &quot;MAC&quot;, &quot;&quot;));
            conf.fake.username = pt.Get(&quot;Fake&quot;, &quot;UserName&quot;, &quot;&quot;);
            conf.fake.password = pt.Get(&quot;Fake&quot;, &quot;PassWord&quot;, &quot;&quot;);
        }
        catch (std::exception&amp; e) {
            SYS_LOG_ERR(&quot;Failed to read fake settings - &quot; &lt;&lt; e.what() &lt;&lt; std::endl);
            return EBADF;
        }
        
        SYS_LOG_INFO(&quot;Fetch fake settings successfully.&quot; &lt;&lt; std::endl);
        SYS_LOG_INFO(&quot;Fake.MAC = &quot; &lt;&lt; hex_to_str(&amp;conf.fake.mac[0], 6, &#x27;:&#x27;) &lt;&lt; &quot;, Fake.UserName = &quot; &lt;&lt; conf.fake.username &lt;&lt; &quot;, Fake.PassWord = &quot; &lt;&lt; conf.fake.password &lt;&lt; std::endl);
        
    }
    SYS_LOG_INFO(&quot;Loaded config successfully.&quot; &lt;&lt; std::endl);
    
    return 0;
}

std::shared_ptr&lt;eap_dealer&gt; eap;
std::shared_ptr&lt;drcom_dealer_base&gt; drcom;

enum ONLINE_STATE
{
    OFFLINE_PROCESSING,
    OFFLINE_NOTIFY,
    OFFLINE,
    ONLINE_PROCESSING,
    ONLINE,
};
ONLINE_STATE state = OFFLINE;

std::mutex mtx;
std::condition_variable cv;

std::vector&lt;uint8_t&gt; broadcast_mac = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };
std::vector&lt;uint8_t&gt; nearest_mac = { 0x01, 0x80, 0xc2, 0x00, 0x00, 0x03 };

void online_func()
{
    do
    {
        try
        {
            do
            {
                state = ONLINE_PROCESSING;
				try
                {
                    if (conf.general.mode != 1) // 宿舍区认证模式
                    {
                        if (conf.remote.use_broadcast)
                        {
                            eap-&gt;logoff(nearest_mac);
                            eap-&gt;logoff(nearest_mac);
                            
                            if (eap-&gt;start(broadcast_mac)) break;
                            if (eap-&gt;response_identity(broadcast_mac)) break;
                            if (eap-&gt;response_md5_challenge(broadcast_mac)) break;
                        }
                        else
                        {
                            eap-&gt;logoff(conf.remote.mac);
                            eap-&gt;logoff(conf.remote.mac);
                            
                            if (eap-&gt;start(conf.remote.mac)) break;
                            if (eap-&gt;response_identity(conf.remote.mac)) break;
                            if (eap-&gt;response_md5_challenge(conf.remote.mac)) break;
                        }
                    }
                    
                    if (conf.general.mode &lt;= 1) // U31.R0
                    {
                        std::shared_ptr&lt;drcom_dealer_u31&gt; dealer = std::dynamic_pointer_cast&lt;drcom_dealer_u31&gt;(drcom);
                        
                        if (dealer-&gt;start_request()) break;
                        if (dealer-&gt;send_login_auth()) break;
                    }
                    else // U62.R0
                    {
                        std::shared_ptr&lt;drcom_dealer_u62&gt; dealer = std::dynamic_pointer_cast&lt;drcom_dealer_u62&gt;(drcom);
                    }
                    
                    while (true &amp;&amp; state != OFFLINE_PROCESSING) // Keep Alive
                    {
                        try
                        {
                            if (conf.general.mode &lt;= 1) // U31.R0
                            {
                                std::shared_ptr&lt;drcom_dealer_u31&gt; dealer = std::dynamic_pointer_cast&lt;drcom_dealer_u31&gt;(drcom);
                                
                                if (dealer-&gt;send_alive_request()) break;
                                if (dealer-&gt;send_alive_pkt1()) break;
                                if (dealer-&gt;send_alive_pkt2()) break;
                            }
                            else // U62.R0
                            {
                                std::shared_ptr&lt;drcom_dealer_u62&gt; dealer = std::dynamic_pointer_cast&lt;drcom_dealer_u62&gt;(drcom);
                            
                                if (dealer-&gt;send_alive_pkt1()) break;
                                if (dealer-&gt;send_alive_pkt2()) break;
                            }
                            
                            state = ONLINE;
                            
                            std::unique_lock&lt;std::mutex&gt; lock(mtx);
                            cv.wait_for(lock, std::chrono::seconds(20));
                        }
                        catch (std::exception&amp; e)
                        {
                            state = OFFLINE;
                            SYS_LOG_ERR(&quot;Keep Alive: &quot; &lt;&lt; e.what() &lt;&lt; std::endl);
                            break;
                        }
                    }
                }
				catch (std::exception&amp; e)
                {
                    state = OFFLINE;
                    SYS_LOG_ERR(&quot;Go Online: &quot; &lt;&lt; e.what() &lt;&lt; std::endl);
                    break;
                }
                
                if (state != OFFLINE_PROCESSING)
                    state = OFFLINE;
            }
            while (false); // run once
            
            if (state != OFFLINE_PROCESSING)
            {
                SYS_LOG_INFO(&quot;Connection broken, try to redial after 5 seconds.&quot; &lt;&lt; std::endl);
                std::this_thread::sleep_for(std::chrono::seconds(5));
            }
        }
        catch (std::exception&amp; e)
        {
            SYS_LOG_ERR(&quot;Thread Online: &quot; &lt;&lt; e.what() &lt;&lt; std::endl);
        }
    } while (conf.general.auto_redial &amp;&amp; state != OFFLINE_PROCESSING); // auto redial
    
    std::unique_lock&lt;std::mutex&gt; lock(mtx);
    state = OFFLINE_NOTIFY;
    cv.notify_one();
}

void offline_func()
{
    try
    {
        state = OFFLINE_PROCESSING;
        
        std::unique_lock&lt;std::mutex&gt; lock(mtx);
        cv.notify_one();
        
        while (state != OFFLINE_NOTIFY)
            cv.wait(lock); // wait for signal
        
        if (conf.general.mode &lt;= 1) // U31.R0
        {
            std::shared_ptr&lt;drcom_dealer_u31&gt; dealer = std::dynamic_pointer_cast&lt;drcom_dealer_u31&gt;(drcom);
            
            dealer-&gt;send_alive_request();
            dealer-&gt;start_request();
            dealer-&gt;send_logout_auth();
        }
        // U62.R0 needn&#x27;t do anything
    }
    catch (std::exception&amp; e)
    {
        SYS_LOG_ERR(&quot;Go Offline: &quot; &lt;&lt; e.what() &lt;&lt; std::endl);
    }
    
    if (conf.general.mode == 0 || conf.general.mode == 2) // 宿舍区
    {
        if (conf.remote.use_broadcast)
        {
            eap-&gt;logoff(broadcast_mac);
            eap-&gt;logoff(nearest_mac);
        }
        else
        {
            eap-&gt;logoff(conf.remote.mac);
        }
    }

    state = OFFLINE;
    SYS_LOG_INFO(&quot;Offline.&quot; &lt;&lt; std::endl);
}

int main(int argc, const char * argv[])
{
    int ret = 0;
    bool background = false, redirect_to_null = false;
    std::string config_path = &quot;EasyDrcom.conf&quot;;
    auto clog_def = std::clog.rdbuf();
    auto cout_def = std::cout.rdbuf();
    auto cerr_def = std::cerr.rdbuf();
#ifdef OPENWRT
    std::string log_path = &quot;/tmp/EasyDrcom.log&quot;;
#else
    std::string log_path = &quot;EasyDrcom.log&quot;;
#endif
    
    for (int i = 1; i &lt; argc; i++)
    {
        if (!strcmp(argv[i], &quot;-b&quot;))
            background = true;
        else if (!strcmp(argv[i], &quot;-r&quot;))
            redirect_to_null = true;
        else if (!strcmp(argv[i], &quot;-c&quot;))
        {
            if (i + 1 &lt; argc)
                config_path = argv[i+1];
        }
        else if (!strcmp(argv[i], &quot;-o&quot;))
        {
            if (i + 1 &lt; argc)
                log_path = argv[i+1];
        }
    }
    
    std::ofstream log(log_path);
    if (!log.is_open())
    {
        std::cerr &lt;&lt; &quot;[Error] Failed to open log &#x27;&quot; &lt;&lt; log_path &lt;&lt; &quot;&#x27;, quitting...&quot; &lt;&lt; std::endl;
        return ENOENT;
    }
    std::clog.rdbuf(log.rdbuf());
    
    std::ofstream null(&quot;/dev/null&quot;);
    if (redirect_to_null)
    {
        std::cout.rdbuf(null.rdbuf());
        std::cerr.rdbuf(null.rdbuf());
    }
    
    SYS_LOG_INFO(&quot;EasyDrcom &quot; &lt;&lt; VERSION &lt;&lt; &quot; (build on &quot; &lt;&lt; __DATE__ &lt;&lt; &quot; &quot; &lt;&lt; __TIME__ &lt;&lt; &quot;)&quot; &lt;&lt; std::endl);
    SYS_LOG_INFO(&quot;Code by Shindo, Contributors: mylight, SwimmingTiger.&quot; &lt;&lt; std::endl &lt;&lt; std::endl);
    SYS_LOG_INFO(&quot;Initializing...&quot; &lt;&lt; std::endl);
    SYS_LOG_INFO(&quot;Loading config from &#x27;&quot; &lt;&lt; config_path &lt;&lt; &quot;&#x27;...&quot; &lt;&lt; std::endl);
    
    // Initialization
    if ((ret = read_config(config_path)) != 0)
        goto end;
    
    
#if defined(WIN32)
	WSADATA	wsa;
	WSAStartup(MAKEWORD(2, 2), &amp;wsa);
#endif
    
    try
    {
        eap = std::shared_ptr&lt;eap_dealer&gt;(new eap_dealer(conf.local.nic, conf.local.mac, conf.local.ip, conf.general.username, conf.general.password)); // the fucking &quot;Segmentation fault&quot;, so we must have to use this line all the time!!!
        
        if (!conf.fake.enable)
        {
            if (conf.general.mode &lt;= 1) // U31.R0
                drcom = std::shared_ptr&lt;drcom_dealer_base&gt;(new drcom_dealer_u31(conf.local.mac, conf.local.ip, conf.general.username, conf.general.password, conf.remote.ip, conf.remote.port, conf.local.hostname, conf.local.kernel_version));
            else // U62.R0
                drcom = std::shared_ptr&lt;drcom_dealer_base&gt;(new drcom_dealer_u62(conf.local.mac, conf.local.ip, conf.general.username, conf.general.password, conf.remote.ip, conf.remote.port, conf.local.hostname, conf.local.kernel_version));
        }
        else
        {
            if (conf.general.mode &lt;= 1) // U31.R0
                drcom = std::shared_ptr&lt;drcom_dealer_base&gt;(new drcom_dealer_u31(conf.fake.mac, conf.local.ip, conf.fake.username, conf.fake.password, conf.remote.ip, conf.remote.port, conf.local.hostname, conf.local.kernel_version));
            else // U62.R0
                drcom = std::shared_ptr&lt;drcom_dealer_base&gt;(new drcom_dealer_u62(conf.fake.mac, conf.local.ip, conf.fake.username, conf.fake.password, conf.remote.ip, conf.remote.port, conf.local.hostname, conf.local.kernel_version));
        }
    }
    catch (std::exception&amp; e)
    {
        SYS_LOG_ERR(e.what() &lt;&lt; std::endl);
        ret = ENETRESET;
        goto end;
    }
    
    SYS_LOG_INFO(&quot;Initialization done!&quot; &lt;&lt; std::endl);
    
    if (background)
    {
        SYS_LOG_INFO(&quot;Start in background, turn on Auto Online &amp; Auto Redial.&quot; &lt;&lt; std::endl);
        conf.general.auto_online = true;
        conf.general.auto_redial = true;
    }
    
    if (!background)
        SYS_LOG_INFO(&quot;Enter &#x27;help&#x27; to get help.&quot; &lt;&lt; std::endl);
    
    if (!conf.general.auto_online)
    {
        SYS_LOG_INFO(&quot;Enter &#x27;online&#x27; to go online!&quot; &lt;&lt; std::endl);
    }
    else
    {
        SYS_LOG_INFO(&quot;Going online...&quot; &lt;&lt; std::endl);
        std::thread(online_func).detach();
    }
    
    if (background)
    {
        std::thread(online_func).join();
    }
    else
    {
        // Command Loop
        std::string cmd;
        while (true)
        {
            std::cin &gt;&gt; cmd;
            if (!cmd.compare(&quot;online&quot;))
            {
                if (state == ONLINE)
                {
                    SYS_LOG_INFO(&quot;Already online!&quot; &lt;&lt; std::endl);
                }
                else if (state == ONLINE_PROCESSING)
                {
                    SYS_LOG_INFO(&quot;Online Processing!&quot; &lt;&lt; std::endl);
                }
                else if (state == OFFLINE_PROCESSING || state == OFFLINE_NOTIFY)
                {
                    SYS_LOG_INFO(&quot;Offline Processing!&quot; &lt;&lt; std::endl);
                }
                else if (state == OFFLINE)
                {
                    SYS_LOG_INFO(&quot;Going online...&quot; &lt;&lt; std::endl);
                    std::thread(online_func).detach();
                }
            }
            else if (!cmd.compare(&quot;offline&quot;))
            {
                if (state == OFFLINE)
                {
                    SYS_LOG_INFO(&quot;Haven&#x27;t been online!&quot; &lt;&lt; std::endl);
                }
                else if (state == ONLINE_PROCESSING)
                {
                    SYS_LOG_INFO(&quot;Online Processing!&quot; &lt;&lt; std::endl);
                }
                else if (state == OFFLINE_PROCESSING)
                {
                    SYS_LOG_INFO(&quot;Offline Processing!&quot; &lt;&lt; std::endl);
                }
                else if (state == ONLINE)
                {
                    SYS_LOG_INFO(&quot;Going offline...&quot; &lt;&lt; std::endl);
                    std::thread(offline_func).detach();
                }
            }
            else if (!cmd.compare(&quot;quit&quot;))
            {
                if (state == ONLINE_PROCESSING)
                {
                    SYS_LOG_INFO(&quot;Please wait for online processing finished.&quot; &lt;&lt; std::endl);
                    continue;
                }
                
                if (state == OFFLINE_PROCESSING)
                {
                    SYS_LOG_INFO(&quot;Please wait for offline processing finished.&quot; &lt;&lt; std::endl);
                    continue;
                }
                
                if (state == ONLINE)
                {
                    SYS_LOG_INFO(&quot;Going offline...&quot; &lt;&lt; std::endl);
                    offline_func();
                }
                
                SYS_LOG_INFO(&quot;Quitting...&quot; &lt;&lt; std::endl);
                std::cout &lt;&lt; &quot;[EasyDrcom Info] Bye Bye!&quot; &lt;&lt; std::endl;
                break;
            }
            else if (!cmd.compare(&quot;help&quot;))
            {
                SYS_LOG_INFO(&quot;EasyDrcom &quot; &lt;&lt; VERSION &lt;&lt; &quot; (build on &quot; &lt;&lt; __DATE__ &lt;&lt; &quot; &quot; &lt;&lt; __TIME__ &lt;&lt; &quot;)&quot; &lt;&lt; std::endl);
                SYS_LOG_INFO(&quot;Code by Shindo, Contributors: mylight, SwimmingTiger.&quot; &lt;&lt; std::endl &lt;&lt; std::endl);
                SYS_LOG_INFO(&quot;Command list:&quot; &lt;&lt; std::endl);
                SYS_LOG_INFO(&quot;online - go online.&quot; &lt;&lt; std::endl);
                SYS_LOG_INFO(&quot;offline - go offline.&quot; &lt;&lt; std::endl);
                SYS_LOG_INFO(&quot;quit - quit EasyDrcom.&quot; &lt;&lt; std::endl);
            }
            else
            {
                SYS_LOG_INFO(&quot;Wrong command: &quot; &lt;&lt; cmd &lt;&lt; std::endl);
            }
        }
    }
    
end:
    std::cout.rdbuf(cout_def);
    std::cerr.rdbuf(cerr_def);
    std::clog.rdbuf(clog_def);
    
    log.close();
    null.close();
    
#if defined (WIN32)
	WSACleanup();
#endif
    return ret;
}
</code></pre>
<p>6.最后在 src 目录下再建一个 Makefile：</p>
<pre><code class="language-Makefile">LIBS += -lpthread -lpcap -lstdc++
LDFLAGS += -DLINUX -DOPENWRT
CFLAGS += -Os

easydrcom: main.o md5.o   
	$(CXX) $(LDFLAGS) main.o md5.o -o easydrcom $(LIBS)
md5.o: md5.c        
	$(CXX) $(CFLAGS) -c md5.c
main.o: main.cpp
	$(CXX) $(CFLAGS) -c main.cpp
clean: 
	rm *.o
	rm easydrcom
</code></pre>
<p>之后就开始编译，首先 <code>make menuconfig</code> 去掉不需要编译的包，然后 <code>make package/easydrcom/compile -j8 V=s</code> 八核编译，等一会就好了</p>
<p><img src="https://user-images.githubusercontent.com/20496444/146671231-5c2c92eb-a81e-4b30-9bde-5cbcc6e81c22.png" alt="opok"/></p>
<p>附件：
<a href="https://github.com/vanishcode/Blog/files/7701417/hg255d.zip">hg255d.zip</a></p></article></main></div><script src="/_next/static/chunks/webpack-3a35b39d748bae39.js" async=""></script><script src="/_next/static/chunks/3949d24b-b3670977323a3ac7.js" async=""></script><script src="/_next/static/chunks/604-576b6ce5c58b6c72.js" async=""></script><script src="/_next/static/chunks/main-app-df5321dfc4619866.js" async=""></script></body></html><script>(self.__next_f=self.__next_f||[]).push([0])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/media/e4af272ccee01ff0-s.p.woff2\",{\"as\":\"font\",\"type\":\"font/woff2\"}]\n2:HL[\"/_next/static/css/9152c37d2d6aee8c.css\",{\"as\":\"style\"}]\n0:\"$L3\"\n"])</script><script>self.__next_f.push([1,"4:I{\"id\":\"4518\",\"chunks\":[\"272:static/chunks/webpack-3a35b39d748bae39.js\",\"508:static/chunks/3949d24b-b3670977323a3ac7.js\",\"604:static/chunks/604-576b6ce5c58b6c72.js\"],\"name\":\"\",\"async\":false}\n6:I{\"id\":\"6341\",\"chunks\":[\"272:static/chunks/webpack-3a35b39d748bae39.js\",\"508:static/chunks/3949d24b-b3670977323a3ac7.js\",\"604:static/chunks/604-576b6ce5c58b6c72.js\"],\"name\":\"\",\"async\":false}\n7:I{\"id\":\"394\",\"chunks\":[\"485:static/chunks/485-3071997949e00430.js\",\"185:static/chunks/app/layout-0c716af5725e1bc4.js\"],\"name"])</script><script>self.__next_f.push([1,"\":\"ThemeProvider\",\"async\":false}\n8:I{\"id\":\"7749\",\"chunks\":[\"485:static/chunks/485-3071997949e00430.js\",\"185:static/chunks/app/layout-0c716af5725e1bc4.js\"],\"name\":\"ModeToggle\",\"async\":false}\n9:I{\"id\":\"6485\",\"chunks\":[\"485:static/chunks/485-3071997949e00430.js\",\"931:static/chunks/app/page-e79f42fe7bcedc85.js\"],\"name\":\"\",\"async\":false}\na:I{\"id\":\"8900\",\"chunks\":[\"485:static/chunks/485-3071997949e00430.js\",\"185:static/chunks/app/layout-0c716af5725e1bc4.js\"],\"name\":\"Analytics\",\"async\":false}\nb:I{\"id\":\"5813\",\"chun"])</script><script>self.__next_f.push([1,"ks\":[\"272:static/chunks/webpack-3a35b39d748bae39.js\",\"508:static/chunks/3949d24b-b3670977323a3ac7.js\",\"604:static/chunks/604-576b6ce5c58b6c72.js\"],\"name\":\"\",\"async\":false}\nc:I{\"id\":\"8464\",\"chunks\":[\"272:static/chunks/webpack-3a35b39d748bae39.js\",\"508:static/chunks/3949d24b-b3670977323a3ac7.js\",\"604:static/chunks/604-576b6ce5c58b6c72.js\"],\"name\":\"\",\"async\":false}\n"])</script><script>self.__next_f.push([1,"3:[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/9152c37d2d6aee8c.css\",\"precedence\":\"next\"}]],[\"$\",\"$L4\",null,{\"assetPrefix\":\"\",\"initialCanonicalUrl\":\"/posts/drcom\",\"initialTree\":[\"\",{\"children\":[\"posts\",{\"children\":[[\"slug\",\"drcom\",\"c\"],{\"children\":[\"__PAGE__?{\\\"slug\\\":[\\\"drcom\\\"]}\",{}]}]}]},\"$undefined\",\"$undefined\",true],\"initialHead\":[\"$L5\",[\"$\",\"meta\",null,{\"name\":\"next-size-adjust\"}]],\"globalErrorComponent\":\"$6\",\"notFound\":[\"$\",\"html\",null,{\"lang\":\"en\",\"children\":[\"$\",\"body\",null,{\"className\":\"antialiased min-h-screen bg-white dark:bg-slate-950 text-slate-900 dark:text-slate-50 __className_52d07b\",\"children\":[\"$\",\"$L7\",null,{\"attribute\":\"class\",\"defaultTheme\":\"system\",\"enableSystem\":true,\"children\":[[\"$\",\"div\",null,{\"className\":\"max-w-2xl mx-auto py-10 px-4\",\"children\":[[\"$\",\"header\",null,{\"children\":[\"$\",\"div\",null,{\"className\":\"flex items-center justify-between\",\"children\":[[\"$\",\"$L8\",null,{}],[\"$\",\"nav\",null,{\"className\":\"ml-auto text-sm font-medium space-x-6\",\"children\":[[\"$\",\"$L9\",null,{\"href\":\"/\",\"children\":\"Home\"}],[\"$\",\"$L9\",null,{\"href\":\"/about\",\"children\":\"About\"}]]}]]}]}],[\"$\",\"main\",null,{\"children\":[\"$undefined\",[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":\"404\"}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]]]}]]}],[\"$\",\"$La\",null,{}]]}]}]}],\"asNotFound\":false,\"children\":[[\"$\",\"html\",null,{\"lang\":\"en\",\"children\":[\"$\",\"body\",null,{\"className\":\"antialiased min-h-screen bg-white dark:bg-slate-950 text-slate-900 dark:text-slate-50 __className_52d07b\",\"children\":[\"$\",\"$L7\",null,{\"attribute\":\"class\",\"defaultTheme\":\"system\",\"enableSystem\":true,\"children\":[[\"$\",\"div\",null,{\"className\":\"max-w-2xl mx-auto py-10 px-4\",\"children\":[[\"$\",\"header\",null,{\"children\":[\"$\",\"div\",null,{\"className\":\"flex items-center justify-between\",\"children\":[[\"$\",\"$L8\",null,{}],[\"$\",\"nav\",null,{\"className\":\"ml-auto text-sm font-medium space-x-6\",\"children\":[[\"$\",\"$L9\",null,{\"href\":\"/\",\"children\":\"Home\"}],[\"$\",\"$L9\",null,{\"href\":\"/about\",\"children\":\"About\"}]]}]]}]}],[\"$\",\"main\",null,{\"children\":[\"$\",\"$Lb\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"loading\":\"$undefined\",\"loadingStyles\":\"$undefined\",\"hasLoading\":false,\"template\":[\"$\",\"$Lc\",null,{}],\"templateStyles\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"asNotFound\":false,\"childProp\":{\"current\":[\"$\",\"$Lb\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"posts\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"loading\":\"$undefined\",\"loadingStyles\":\"$undefined\",\"hasLoading\":false,\"template\":[\"$\",\"$Lc\",null,{}],\"templateStyles\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"asNotFound\":false,\"childProp\":{\"current\":[\"$\",\"$Lb\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"posts\",\"children\",[\"slug\",\"drcom\",\"c\"],\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"loading\":\"$undefined\",\"loadingStyles\":\"$undefined\",\"hasLoading\":false,\"template\":[\"$\",\"$Lc\",null,{}],\"templateStyles\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"asNotFound\":false,\"childProp\":{\"current\":[\"$Ld\",null],\"segment\":\"__PAGE__?{\\\"slug\\\":[\\\"drcom\\\"]}\"},\"styles\":[]}],\"segment\":[\"slug\",\"drcom\",\"c\"]},\"styles\":[]}],\"segment\":\"posts\"},\"styles\":[]}]}]]}],[\"$\",\"$La\",null,{}]]}]}]}],null]}]]\n"])</script><script>self.__next_f.push([1,"d:[\"$\",\"article\",null,{\"className\":\"py-6 prose dark:prose-invert\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"mb-2\",\"children\":\"在任意 OpenWrt 设备上运行 EasyDrcom\"}],[\"$\",\"p\",null,{\"className\":\"text-xl mt-0 text-slate-700 dark:text-slate-200\",\"children\":\"一块心病的解决 ❤️\"}],[\"$\",\"hr\",null,{\"className\":\"my-4\"}],[[\"$\",\"p\",null,{\"children\":\"“如何在任意刷写了 OpenWrt 的设备上运行 EasyDrcom” 一直是我的一个心病，因为大学期间搞了好多次，搞了好久，时间跨度将近两年也没解决这个问题。不过最近有时间，用了两天时间，终于研究得差不多了。\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"设备以 HG255D 为例\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"开发前要搭建 OpenWrt 交叉编译环境，按照网上教程就可以了，就是在 Ubuntu 上安装各种包。然后开始开发：\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"1.下载对应芯片的 SDK，里面包含了开发一个 OpenWrt 软件包所需要的所有东西。\\n比如 HG255D 是 rampis 厂家 rt3052 芯片，那么最新版 OpenWrt 对应的 SDK 链接就是 https://archive.openwrt.org/releases/21.02.0/targets/ramips/rt305x/openwrt-sdk-21.02.0-ramips-rt305x_gcc-8.4.0_musl.Linux-x86_64.tar.xz\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"OpenWrt 前几个版本差异有点大，而且还出了 LEDE 这样一个 fork，所以你路由里用的什么版本的固件，就要使用什么版本的 SDK，不然兼容性可能有问题。比如 21 的 SDK 编译的软件包在 14 的系统下很有可能是跑不了的。\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"2.解压 SDK，进入文件夹，首先要获取必要的包，运行 \",[\"$\",\"code\",null,{\"children\":\"./script/feeds update -a\"}],\"，之后运行 \",[\"$\",\"code\",null,{\"children\":\"./script/feeds install -af\"}],\" 这样就安装了所有的依赖。如果发生问题，要不是时区的问题，要么是梯子的问题，自行解决吧。\"]}],\"\\n\",[\"$\",\"blockquote\",null,{\"children\":[\"\\n\",[\"$\",\"p\",null,{\"children\":\"其实有 docker 的话还能再简单一点：docker pull openwrtorg/sdk:ramips-rt305x-21.02.1\"}],\"\\n\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"3.在 package 目录下建立我们自己的包，首先建空文件夹命名为 easydrcom，然后创建一个 Makefile，内容如下：\"}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-Makefile\",\"children\":\"###############################################\\n#OpenWrt Makefile for easydrcom program\\n##############################################\\ninclude $(TOPDIR)/rules.mk\\n# Name and release number of this package\\nPKG_NAME:=easydrcom\\nPKG_RELEASE:=1\\n# This specifies the directory where we're going to build the program.\\n# The root build directory, $(BUILD_DIR), is by default the build_mipsel\\n# directory in your OpenWrt SDK directory\\nPKG_BUILD_DIR := $(BUILD_DIR)/$(PKG_NAME)\\ninclude $(INCLUDE_DIR)/package.mk\\n# Specify package information for this program.\\n# The variables defined here should be self explanatory.\\n# If you are running Kamikaze, delete the DESCRIPTION\\n# variable below and uncomment the Kamikaze define\\n# directive for the description below\\ndefine Package/$(PKG_NAME)\\n\\tSECTION:=utils\\n\\tCATEGORY:=Utilities\\n\\tDEPENDS:=+libpcap +libpthread +libstdcpp\\n\\tTITLE:=$(PKG_NAME) -- drcom fro hitwh\\nendef\\n# Uncomment portion below for Kamikaze and delete DESCRIPTION variable above\\ndefine Package/$(PKG_NAME)/description\\n\\tfree wireless at hitwh.\\nendef\\n# Specify what needs to be done to prepare for building the package.\\n# In our case, we need to copy the source files to the build directory.\\n# This is NOT the default.  The default uses the PKG_SOURCE_URL and the\\n# PKG_SOURCE which is not defined here to download the source from the web.\\n# In order to just build a simple program that we have just written, it is\\n# much easier to do it this way.\\ndefine Build/Prepare\\n\\tmkdir -p $(PKG_BUILD_DIR)\\n\\t$(CP) ./src/* $(PKG_BUILD_DIR)/\\nendef\\n# We do not need to define Build/Configure or Build/Compile directives\\n# The defaults are appropriate for compiling a simple program such as this one\\n# Specify where and how to install the program. Since we only have one file,\\n# the easydrcom executable, install it by copying it to the /bin directory on\\n# the router. The $(1) variable represents the root directory on the router running\\n# OpenWrt. The $(INSTALL_DIR) variable contains a command to prepare the install\\n# directory if it does not already exist.  Likewise $(INSTALL_BIN) contains the\\n# command to copy the binary file from its current location (in our case the build\\n# directory) to the install directory.\\ndefine Package/$(PKG_NAME)/install\\n\\t$(INSTALL_DIR) $(1)/bin\\n\\t$(INSTALL_BIN) $(PKG_BUILD_DIR)/$(PKG_NAME) $(1)/bin/\\nendef\\n# This line executes the necessary commands to compile our program.\\n# The above define directives specify all the information needed, but this\\n# line calls BuildPackage which in turn actually uses this information to build a package.\\n$(eval $(call BuildPackage,$(PKG_NAME)))\\n\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"4.建立src文件夹，将 EasyDrcom 的代码复制进去，链接：https://github.com/coverxit/EasyDrcom/tree/master/EasyDrcom\\n这里需要修改一下，我们不用 boost，一是太老了，二是编译时候还需要额外引入 boost，没必要这样。\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"我们使用这个头文件，用一个文件就能解析 init 配置文件：https://github.com/benhoyt/inih\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"复制 https://github.com/benhoyt/inih/tree/master/cpp 下 INIReader.h 到 src 文件夹里\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"5.修改 main.cpp 为\"}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-cpp\",\"children\":\"/**\\n * Copyright (C) 2014 Shindo\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *     http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\n#include \u003cthread\u003e\\n#include \u003cmutex\u003e\\n#include \u003ccondition_variable\u003e\\n#include \u003cchrono\u003e\\n\\n#include \u003ciostream\u003e\\n#include \u003cstring\u003e\\n#include \u003cvector\u003e\\n#include \u003cstdexcept\u003e\\n#include \u003cfunctional\u003e\\n#include \u003cctime\u003e\\n#include \u003cfstream\u003e\\n#include \u003csstream\u003e\\n#include \u003ccctype\u003e\\n\\n#if defined(__APPLE__) || defined(LINUX) || defined(linux)\\n#include \u003csys/types.h\u003e\\n#include \u003carpa/inet.h\u003e\\n#include \u003cnetinet/in.h\u003e\\n#include \u003cnet/ethernet.h\u003e\\n#endif\\n\\n#include \\\"INIReader.h\\\"\\n#include \\\"easy_drcom_exception.hpp\\\"\\n\\nstruct easy_drcom_config {\\n    struct config_general {\\n        int mode;\\n        std::string username;\\n        std::string password;\\n        bool auto_online;\\n        bool auto_redial;\\n    } general;\\n    \\n    struct config_remote {\\n        std::string ip;\\n        uint32_t port;\\n        \\n        bool use_broadcast;\\n        std::vector\u003cuint8_t\u003e mac;\\n    } remote;\\n    \\n    struct config_local {\\n        std::string nic;\\n        std::string hostname;\\n        std::string kernel_version;\\n        \\n        std::string ip;\\n        std::vector\u003cuint8_t\u003e mac;\\n        \\n        uint32_t eap_timeout;\\n        uint32_t udp_timeout;\\n    } local;\\n    \\n    struct config_fake {\\n        bool enable;\\n        std::vector\u003cuint8_t\u003e mac;\\n        std::string username;\\n        std::string password;\\n    } fake;\\n} conf;\\n\\n// Log Config\\n#define EASYDRCOM_DEBUG\\n//#define EASYDRCOM_PRINT_DBG_ON_SCREEN\\n#include \\\"log.hpp\\\"\\n\\n#define MAX_RETRY_TIME 2\\n#include \\\"utils.hpp\\\"\\n#include \\\"drcom_dealer.hpp\\\"\\n#include \\\"eap_dealer.hpp\\\"\\n\\n#define VERSION \\\"v0.9\\\"\\n\\n#if defined (WIN32)\\n#define VERSION (MAJOR_VERSION \\\" for Windows\\\")\\n#elif defined __APPLE__\\n#define VERSION (MAJOR_VERSION \\\" for Mac OSX\\\")\\n#elif defined (OPENWRT)\\n#define VERSION (MAJOR_VERSION \\\" for OpenWrt (mips AR7xxx/9xxx)\\\")\\n#elif defined (LINUX)\\n#define VERSION (MAJOR_VERSION \\\" for Linux\\\")\\n#endif\\n\\nint read_config(std::string path)\\n{\\n    INIReader pt(path);\\n\\n    try {\\n        conf.general.mode = pt.GetInteger(\\\"General\\\", \\\"Mode\\\", 0);\\n        conf.general.username = pt.Get(\\\"General\\\", \\\"UserName\\\", \\\"\\\");\\n        conf.general.password = pt.Get(\\\"General\\\", \\\"PassWord\\\", \\\"\\\");\\n        conf.local.nic = pt.Get(\\\"Local\\\", \\\"NIC\\\", \\\"\\\");\\n    }\\n    catch (std::exception\u0026 e) {\\n        SYS_LOG_ERR(\\\"Failed to read '\\\" \u003c\u003c path \u003c\u003c \\\"' - \\\" \u003c\u003c e.what() \u003c\u003c std::endl);\\n        return EBADF;\\n    }\\n    \\n    conf.general.auto_online = pt.GetBoolean(\\\"General\\\", \\\"AutoOnline\\\", true);\\n    conf.general.auto_redial = pt.GetBoolean(\\\"General\\\", \\\"AutoRedial\\\", true);\\n    \\n    conf.remote.ip = pt.Get(\\\"Remote\\\", \\\"IP\\\", \\\"172.25.8.4\\\");\\n    conf.remote.port = pt.GetBoolean(\\\"Remote\\\", \\\"Port\\\", 61440);\\n    conf.remote.use_broadcast = pt.GetBoolean(\\\"Remote\\\", \\\"UseBroadcast\\\", true);\\n    \\n    if (!conf.remote.use_broadcast)\\n        conf.remote.mac = str_mac_to_vec(pt.Get(\\\"Remote\\\",\\\"MAC\\\", \\\"00:1a:a9:c3:3a:59\\\"));\\n    \\n    conf.local.hostname = pt.Get(\\\"Local\\\", \\\"HostName\\\", \\\"EasyDrcom for HITwh\\\");\\n    conf.local.kernel_version = pt.Get(\\\"Local\\\",\\\"KernelVersion\\\", \\\"0.7\\\");\\n    \\n    conf.local.eap_timeout = pt.GetInteger(\\\"Local\\\", \\\"EAPTimeout\\\", 1000);\\n    conf.local.udp_timeout = pt.GetInteger(\\\"Local\\\", \\\"UDPTimeout\\\", 2000);\\n    \\n    conf.fake.enable = pt.GetInteger(\\\"Fake\\\", \\\"Enable\\\", 0);\\n    \\n    SYS_LOG_DBG(\\\"General.UserName = \\\" \u003c\u003c conf.general.username \u003c\u003c \\\", General.PassWord = \\\" \u003c\u003c conf.general.password \u003c\u003c \\\", General.Mode = \\\" \u003c\u003c conf.general.mode \u003c\u003c std::endl);\\n    SYS_LOG_DBG(\\\"General.AutoOnline = \\\" \u003c\u003c (conf.general.auto_online ? \\\"True\\\" : \\\"False\\\") \u003c\u003c \\\", General.AutoRedial = \\\" \u003c\u003c (conf.general.auto_redial ? \\\"True\\\" : \\\"False\\\" ) \u003c\u003c std::endl);\\n    SYS_LOG_DBG(\\\"Remote.IP:Port = \\\" \u003c\u003c conf.remote.ip \u003c\u003c \\\":\\\" \u003c\u003c conf.remote.port \u003c\u003c \\\", Remote.UseBroadcast = \\\" \u003c\u003c (conf.remote.use_broadcast ? \\\"True\\\" : \\\"False\\\" ) \u003c\u003c std::endl);\\n    if (!conf.remote.use_broadcast) SYS_LOG_DBG(\\\"Remote.MAC = \\\" \u003c\u003c hex_to_str(\u0026conf.remote.mac[0], 6, ':') \u003c\u003c std::endl);\\n    SYS_LOG_DBG(\\\"Local.NIC = \\\" \u003c\u003c conf.local.nic \u003c\u003c \\\", Local.HostName = \\\" \u003c\u003c conf.local.hostname \u003c\u003c \\\", Local.KernelVersion = \\\" \u003c\u003c conf.local.kernel_version \u003c\u003c std::endl);\\n    SYS_LOG_DBG(\\\"Local.EAPTimeout = \\\" \u003c\u003c conf.local.eap_timeout \u003c\u003c \\\", Local.UDPTimeout = \\\" \u003c\u003c conf.local.udp_timeout \u003c\u003c std::endl);\\n    \\n    try {\\n        conf.local.ip = get_ip_address(conf.local.nic);\\n        conf.local.mac = get_mac_address(conf.local.nic);\\n        \\n        SYS_LOG_INFO(\\\"Fetch NIC IP \u0026 MAC successfully.\\\" \u003c\u003c std::endl);\\n        SYS_LOG_INFO(\\\"Local.IP = \\\" \u003c\u003c conf.local.ip \u003c\u003c \\\", Local.MAC = \\\" \u003c\u003c hex_to_str(\u0026conf.local.mac[0], 6, ':') \u003c\u003c std::endl);\\n    }\\n    catch (std::exception\u0026 e) {\\n        SYS_LOG_ERR(\\\"Failed to fetch NIC info - \\\" \u003c\u003c e.what() \u003c\u003c std::endl);\\n        return EBADF;\\n    }\\n    \\n    if (conf.fake.enable) // fake user\\n    {\\n        try {\\n            conf.fake.mac = str_mac_to_vec(pt.Get(\\\"Fake\\\", \\\"MAC\\\", \\\"\\\"));\\n            conf.fake.username = pt.Get(\\\"Fake\\\", \\\"UserName\\\", \\\"\\\");\\n            conf.fake.password = pt.Get(\\\"Fake\\\", \\\"PassWord\\\", \\\"\\\");\\n        }\\n        catch (std::exception\u0026 e) {\\n            SYS_LOG_ERR(\\\"Failed to read fake settings - \\\" \u003c\u003c e.what() \u003c\u003c std::endl);\\n            return EBADF;\\n        }\\n        \\n        SYS_LOG_INFO(\\\"Fetch fake settings successfully.\\\" \u003c\u003c std::endl);\\n        SYS_LOG_INFO(\\\"Fake.MAC = \\\" \u003c\u003c hex_to_str(\u0026conf.fake.mac[0], 6, ':') \u003c\u003c \\\", Fake.UserName = \\\" \u003c\u003c conf.fake.username \u003c\u003c \\\", Fake.PassWord = \\\" \u003c\u003c conf.fake.password \u003c\u003c std::endl);\\n        \\n    }\\n    SYS_LOG_INFO(\\\"Loaded config successfully.\\\" \u003c\u003c std::endl);\\n    \\n    return 0;\\n}\\n\\nstd::shared_ptr\u003ceap_dealer\u003e eap;\\nstd::shared_ptr\u003cdrcom_dealer_base\u003e drcom;\\n\\nenum ONLINE_STATE\\n{\\n    OFFLINE_PROCESSING,\\n    OFFLINE_NOTIFY,\\n    OFFLINE,\\n    ONLINE_PROCESSING,\\n    ONLINE,\\n};\\nONLINE_STATE state = OFFLINE;\\n\\nstd::mutex mtx;\\nstd::condition_variable cv;\\n\\nstd::vector\u003cuint8_t\u003e broadcast_mac = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };\\nstd::vector\u003cuint8_t\u003e nearest_mac = { 0x01, 0x80, 0xc2, 0x00, 0x00, 0x03 };\\n\\nvoid online_func()\\n{\\n    do\\n    {\\n        try\\n        {\\n            do\\n            {\\n                state = ONLINE_PROCESSING;\\n\\t\\t\\t\\ttry\\n                {\\n                    if (conf.general.mode != 1) // 宿舍区认证模式\\n                    {\\n                        if (conf.remote.use_broadcast)\\n                        {\\n                            eap-\u003elogoff(nearest_mac);\\n                            eap-\u003elogoff(nearest_mac);\\n                            \\n                            if (eap-\u003estart(broadcast_mac)) break;\\n                            if (eap-\u003eresponse_identity(broadcast_mac)) break;\\n                            if (eap-\u003eresponse_md5_challenge(broadcast_mac)) break;\\n                        }\\n                        else\\n                        {\\n                            eap-\u003elogoff(conf.remote.mac);\\n                            eap-\u003elogoff(conf.remote.mac);\\n                            \\n                            if (eap-\u003estart(conf.remote.mac)) break;\\n                            if (eap-\u003eresponse_identity(conf.remote.mac)) break;\\n                            if (eap-\u003eresponse_md5_challenge(conf.remote.mac)) break;\\n                        }\\n                    }\\n                    \\n                    if (conf.general.mode \u003c= 1) // U31.R0\\n                    {\\n                        std::shared_ptr\u003cdrcom_dealer_u31\u003e dealer = std::dynamic_pointer_cast\u003cdrcom_dealer_u31\u003e(drcom);\\n                        \\n                        if (dealer-\u003estart_request()) break;\\n                        if (dealer-\u003esend_login_auth()) break;\\n                    }\\n                    else // U62.R0\\n                    {\\n                        std::shared_ptr\u003cdrcom_dealer_u62\u003e dealer = std::dynamic_pointer_cast\u003cdrcom_dealer_u62\u003e(drcom);\\n                    }\\n                    \\n                    while (true \u0026\u0026 state != OFFLINE_PROCESSING) // Keep Alive\\n                    {\\n                        try\\n                        {\\n                            if (conf.general.mode \u003c= 1) // U31.R0\\n                            {\\n                                std::shared_ptr\u003cdrcom_dealer_u31\u003e dealer = std::dynamic_pointer_cast\u003cdrcom_dealer_u31\u003e(drcom);\\n                                \\n                                if (dealer-\u003esend_alive_request()) break;\\n                                if (dealer-\u003esend_alive_pkt1()) break;\\n                                if (dealer-\u003esend_alive_pkt2()) break;\\n                            }\\n                            else // U62.R0\\n                            {\\n                                std::shared_ptr\u003cdrcom_dealer_u62\u003e dealer = std::dynamic_pointer_cast\u003cdrcom_dealer_u62\u003e(drcom);\\n                            \\n                                if (dealer-\u003esend_alive_pkt1()) break;\\n                                if (dealer-\u003esend_alive_pkt2()) break;\\n                            }\\n                            \\n                            state = ONLINE;\\n                            \\n                            std::unique_lock\u003cstd::mutex\u003e lock(mtx);\\n                            cv.wait_for(lock, std::chrono::seconds(20));\\n                        }\\n                        catch (std::exception\u0026 e)\\n                        {\\n                            state = OFFLINE;\\n                            SYS_LOG_ERR(\\\"Keep Alive: \\\" \u003c\u003c e.what() \u003c\u003c std::endl);\\n                            break;\\n                        }\\n                    }\\n                }\\n\\t\\t\\t\\tcatch (std::exception\u0026 e)\\n                {\\n                    state = OFFLINE;\\n                    SYS_LOG_ERR(\\\"Go Online: \\\" \u003c\u003c e.what() \u003c\u003c std::endl);\\n                    break;\\n                }\\n                \\n                if (state != OFFLINE_PROCESSING)\\n                    state = OFFLINE;\\n            }\\n            while (false); // run once\\n            \\n            if (state != OFFLINE_PROCESSING)\\n            {\\n                SYS_LOG_INFO(\\\"Connection broken, try to redial after 5 seconds.\\\" \u003c\u003c std::endl);\\n                std::this_thread::sleep_for(std::chrono::seconds(5));\\n            }\\n        }\\n        catch (std::exception\u0026 e)\\n        {\\n            SYS_LOG_ERR(\\\"Thread Online: \\\" \u003c\u003c e.what() \u003c\u003c std::endl);\\n        }\\n    } while (conf.general.auto_redial \u0026\u0026 state != OFFLINE_PROCESSING); // auto redial\\n    \\n    std::unique_lock\u003cstd::mutex\u003e lock(mtx);\\n    state = OFFLINE_NOTIFY;\\n    cv.notify_one();\\n}\\n\\nvoid offline_func()\\n{\\n    try\\n    {\\n        state = OFFLINE_PROCESSING;\\n        \\n        std::unique_lock\u003cstd::mutex\u003e lock(mtx);\\n        cv.notify_one();\\n        \\n        while (state != OFFLINE_NOTIFY)\\n            cv.wait(lock); // wait for signal\\n        \\n        if (conf.general.mode \u003c= 1) // U31.R0\\n        {\\n            std::shared_ptr\u003cdrcom_dealer_u31\u003e dealer = std::dynamic_pointer_cast\u003cdrcom_dealer_u31\u003e(drcom);\\n            \\n            dealer-\u003esend_alive_request();\\n            dealer-\u003estart_request();\\n            dealer-\u003esend_logout_auth();\\n        }\\n        // U62.R0 needn't do anything\\n    }\\n    catch (std::exception\u0026 e)\\n    {\\n        SYS_LOG_ERR(\\\"Go Offline: \\\" \u003c\u003c e.what() \u003c\u003c std::endl);\\n    }\\n    \\n    if (conf.general.mode == 0 || conf.general.mode == 2) // 宿舍区\\n    {\\n        if (conf.remote.use_broadcast)\\n        {\\n            eap-\u003elogoff(broadcast_mac);\\n            eap-\u003elogoff(nearest_mac);\\n        }\\n        else\\n        {\\n            eap-\u003elogoff(conf.remote.mac);\\n        }\\n    }\\n\\n    state = OFFLINE;\\n    SYS_LOG_INFO(\\\"Offline.\\\" \u003c\u003c std::endl);\\n}\\n\\nint main(int argc, const char * argv[])\\n{\\n    int ret = 0;\\n    bool background = false, redirect_to_null = false;\\n    std::string config_path = \\\"EasyDrcom.conf\\\";\\n    auto clog_def = std::clog.rdbuf();\\n    auto cout_def = std::cout.rdbuf();\\n    auto cerr_def = std::cerr.rdbuf();\\n#ifdef OPENWRT\\n    std::string log_path = \\\"/tmp/EasyDrcom.log\\\";\\n#else\\n    std::string log_path = \\\"EasyDrcom.log\\\";\\n#endif\\n    \\n    for (int i = 1; i \u003c argc; i++)\\n    {\\n        if (!strcmp(argv[i], \\\"-b\\\"))\\n            background = true;\\n        else if (!strcmp(argv[i], \\\"-r\\\"))\\n            redirect_to_null = true;\\n        else if (!strcmp(argv[i], \\\"-c\\\"))\\n        {\\n            if (i + 1 \u003c argc)\\n                config_path = argv[i+1];\\n        }\\n        else if (!strcmp(argv[i], \\\"-o\\\"))\\n        {\\n            if (i + 1 \u003c argc)\\n                log_path = argv[i+1];\\n        }\\n    }\\n    \\n    std::ofstream log(log_path);\\n    if (!log.is_open())\\n    {\\n        std::cerr \u003c\u003c \\\"[Error] Failed to open log '\\\" \u003c\u003c log_path \u003c\u003c \\\"', quitting...\\\" \u003c\u003c std::endl;\\n        return ENOENT;\\n    }\\n    std::clog.rdbuf(log.rdbuf());\\n    \\n    std::ofstream null(\\\"/dev/null\\\");\\n    if (redirect_to_null)\\n    {\\n        std::cout.rdbuf(null.rdbuf());\\n        std::cerr.rdbuf(null.rdbuf());\\n    }\\n    \\n    SYS_LOG_INFO(\\\"EasyDrcom \\\" \u003c\u003c VERSION \u003c\u003c \\\" (build on \\\" \u003c\u003c __DATE__ \u003c\u003c \\\" \\\" \u003c\u003c __TIME__ \u003c\u003c \\\")\\\" \u003c\u003c std::endl);\\n    SYS_LOG_INFO(\\\"Code by Shindo, Contributors: mylight, SwimmingTiger.\\\" \u003c\u003c std::endl \u003c\u003c std::endl);\\n    SYS_LOG_INFO(\\\"Initializing...\\\" \u003c\u003c std::endl);\\n    SYS_LOG_INFO(\\\"Loading config from '\\\" \u003c\u003c config_path \u003c\u003c \\\"'...\\\" \u003c\u003c std::endl);\\n    \\n    // Initialization\\n    if ((ret = read_config(config_path)) != 0)\\n        goto end;\\n    \\n    \\n#if defined(WIN32)\\n\\tWSADATA\\twsa;\\n\\tWSAStartup(MAKEWORD(2, 2), \u0026wsa);\\n#endif\\n    \\n    try\\n    {\\n        eap = std::shared_ptr\u003ceap_dealer\u003e(new eap_dealer(conf.local.nic, conf.local.mac, conf.local.ip, conf.general.username, conf.general.password)); // the fucking \\\"Segmentation fault\\\", so we must have to use this line all the time!!!\\n        \\n        if (!conf.fake.enable)\\n        {\\n            if (conf.general.mode \u003c= 1) // U31.R0\\n                drcom = std::shared_ptr\u003cdrcom_dealer_base\u003e(new drcom_dealer_u31(conf.local.mac, conf.local.ip, conf.general.username, conf.general.password, conf.remote.ip, conf.remote.port, conf.local.hostname, conf.local.kernel_version));\\n            else // U62.R0\\n                drcom = std::shared_ptr\u003cdrcom_dealer_base\u003e(new drcom_dealer_u62(conf.local.mac, conf.local.ip, conf.general.username, conf.general.password, conf.remote.ip, conf.remote.port, conf.local.hostname, conf.local.kernel_version));\\n        }\\n        else\\n        {\\n            if (conf.general.mode \u003c= 1) // U31.R0\\n                drcom = std::shared_ptr\u003cdrcom_dealer_base\u003e(new drcom_dealer_u31(conf.fake.mac, conf.local.ip, conf.fake.username, conf.fake.password, conf.remote.ip, conf.remote.port, conf.local.hostname, conf.local.kernel_version));\\n            else // U62.R0\\n                drcom = std::shared_ptr\u003cdrcom_dealer_base\u003e(new drcom_dealer_u62(conf.fake.mac, conf.local.ip, conf.fake.username, conf.fake.password, conf.remote.ip, conf.remote.port, conf.local.hostname, conf.local.kernel_version));\\n        }\\n    }\\n    catch (std::exception\u0026 e)\\n    {\\n        SYS_LOG_ERR(e.what() \u003c\u003c std::endl);\\n        ret = ENETRESET;\\n        goto end;\\n    }\\n    \\n    SYS_LOG_INFO(\\\"Initialization done!\\\" \u003c\u003c std::endl);\\n    \\n    if (background)\\n    {\\n        SYS_LOG_INFO(\\\"Start in background, turn on Auto Online \u0026 Auto Redial.\\\" \u003c\u003c std::endl);\\n        conf.general.auto_online = true;\\n        conf.general.auto_redial = true;\\n    }\\n    \\n    if (!background)\\n        SYS_LOG_INFO(\\\"Enter 'help' to get help.\\\" \u003c\u003c std::endl);\\n    \\n    if (!conf.general.auto_online)\\n    {\\n        SYS_LOG_INFO(\\\"Enter 'online' to go online!\\\" \u003c\u003c std::endl);\\n    }\\n    else\\n    {\\n        SYS_LOG_INFO(\\\"Going online...\\\" \u003c\u003c std::endl);\\n        std::thread(online_func).detach();\\n    }\\n    \\n    if (background)\\n    {\\n        std::thread(online_func).join();\\n    }\\n    else\\n    {\\n        // Command Loop\\n        std::string cmd;\\n        while (true)\\n        {\\n            std::cin \u003e\u003e cmd;\\n            if (!cmd.compare(\\\"online\\\"))\\n            {\\n                if (state == ONLINE)\\n                {\\n                    SYS_LOG_INFO(\\\"Already online!\\\" \u003c\u003c std::endl);\\n                }\\n                else if (state == ONLINE_PROCESSING)\\n                {\\n                    SYS_LOG_INFO(\\\"Online Processing!\\\" \u003c\u003c std::endl);\\n                }\\n                else if (state == OFFLINE_PROCESSING || state == OFFLINE_NOTIFY)\\n                {\\n                    SYS_LOG_INFO(\\\"Offline Processing!\\\" \u003c\u003c std::endl);\\n                }\\n                else if (state == OFFLINE)\\n                {\\n                    SYS_LOG_INFO(\\\"Going online...\\\" \u003c\u003c std::endl);\\n                    std::thread(online_func).detach();\\n                }\\n            }\\n            else if (!cmd.compare(\\\"offline\\\"))\\n            {\\n                if (state == OFFLINE)\\n                {\\n                    SYS_LOG_INFO(\\\"Haven't been online!\\\" \u003c\u003c std::endl);\\n                }\\n                else if (state == ONLINE_PROCESSING)\\n                {\\n                    SYS_LOG_INFO(\\\"Online Processing!\\\" \u003c\u003c std::endl);\\n                }\\n                else if (state == OFFLINE_PROCESSING)\\n                {\\n                    SYS_LOG_INFO(\\\"Offline Processing!\\\" \u003c\u003c std::endl);\\n                }\\n                else if (state == ONLINE)\\n                {\\n                    SYS_LOG_INFO(\\\"Going offline...\\\" \u003c\u003c std::endl);\\n                    std::thread(offline_func).detach();\\n                }\\n            }\\n            else if (!cmd.compare(\\\"quit\\\"))\\n            {\\n                if (state == ONLINE_PROCESSING)\\n                {\\n                    SYS_LOG_INFO(\\\"Please wait for online processing finished.\\\" \u003c\u003c std::endl);\\n                    continue;\\n                }\\n                \\n                if (state == OFFLINE_PROCESSING)\\n                {\\n                    SYS_LOG_INFO(\\\"Please wait for offline processing finished.\\\" \u003c\u003c std::endl);\\n                    continue;\\n                }\\n                \\n                if (state == ONLINE)\\n                {\\n                    SYS_LOG_INFO(\\\"Going offline...\\\" \u003c\u003c std::endl);\\n                    offline_func();\\n                }\\n                \\n                SYS_LOG_INFO(\\\"Quitting...\\\" \u003c\u003c std::endl);\\n                std::cout \u003c\u003c \\\"[EasyDrcom Info] Bye Bye!\\\" \u003c\u003c std::endl;\\n                break;\\n            }\\n            else if (!cmd.compare(\\\"help\\\"))\\n            {\\n                SYS_LOG_INFO(\\\"EasyDrcom \\\" \u003c\u003c VERSION \u003c\u003c \\\" (build on \\\" \u003c\u003c __DATE__ \u003c\u003c \\\" \\\" \u003c\u003c __TIME__ \u003c\u003c \\\")\\\" \u003c\u003c std::endl);\\n                SYS_LOG_INFO(\\\"Code by Shindo, Contributors: mylight, SwimmingTiger.\\\" \u003c\u003c std::endl \u003c\u003c std::endl);\\n                SYS_LOG_INFO(\\\"Command list:\\\" \u003c\u003c std::endl);\\n                SYS_LOG_INFO(\\\"online - go online.\\\" \u003c\u003c std::endl);\\n                SYS_LOG_INFO(\\\"offline - go offline.\\\" \u003c\u003c std::endl);\\n                SYS_LOG_INFO(\\\"quit - quit EasyDrcom.\\\" \u003c\u003c std::endl);\\n            }\\n            else\\n            {\\n                SYS_LOG_INFO(\\\"Wrong command: \\\" \u003c\u003c cmd \u003c\u003c std::endl);\\n            }\\n        }\\n    }\\n    \\nend:\\n    std::cout.rdbuf(cout_def);\\n    std::cerr.rdbuf(cerr_def);\\n    std::clog.rdbuf(clog_def);\\n    \\n    log.close();\\n    null.close();\\n    \\n#if defined (WIN32)\\n\\tWSACleanup();\\n#endif\\n    return ret;\\n}\\n\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"6.最后在 src 目录下再建一个 Makefile：\"}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-Makefile\",\"children\":\"LIBS += -lpthread -lpcap -lstdc++\\nLDFLAGS += -DLINUX -DOPENWRT\\nCFLAGS += -Os\\n\\neasydrcom: main.o md5.o   \\n\\t$(CXX) $(LDFLAGS) main.o md5.o -o easydrcom $(LIBS)\\nmd5.o: md5.c        \\n\\t$(CXX) $(CFLAGS) -c md5.c\\nmain.o: main.cpp\\n\\t$(CXX) $(CFLAGS) -c main.cpp\\nclean: \\n\\trm *.o\\n\\trm easydrcom\\n\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"之后就开始编译，首先 \",[\"$\",\"code\",null,{\"children\":\"make menuconfig\"}],\" 去掉不需要编译的包，然后 \",[\"$\",\"code\",null,{\"children\":\"make package/easydrcom/compile -j8 V=s\"}],\" 八核编译，等一会就好了\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"$\",\"img\",null,{\"src\":\"https://user-images.githubusercontent.com/20496444/146671231-5c2c92eb-a81e-4b30-9bde-5cbcc6e81c22.png\",\"alt\":\"opok\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"附件：\\n\",[\"$\",\"a\",null,{\"href\":\"https://github.com/vanishcode/Blog/files/7701417/hg255d.zip\",\"children\":\"hg255d.zip\"}]]}]]]}]\n"])</script><script>self.__next_f.push([1,"5:[[[\"$\",\"meta\",null,{\"charSet\":\"utf-8\"}],[\"$\",\"title\",null,{\"children\":\"在任意 OpenWrt 设备上运行 EasyDrcom\"}],[\"$\",\"meta\",null,{\"name\":\"description\",\"content\":\"一块心病的解决 ❤️\"}],null,null,null,null,null,null,null,null,[\"$\",\"meta\",null,{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],null,null,null,null,null,null,null,null,null,null,[]],[null,null,null,null],null,null,[null,null,null,null,null],null,null,null,null,[null,[[\"$\",\"link\",null,{\"rel\":\"icon\",\"href\":\"/favicon.ico\",\"type\":\"image/x-icon\",\"sizes\":\"any\"}]],[],null]]\n"])</script>