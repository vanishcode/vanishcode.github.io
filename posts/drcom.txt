1:HL["/_next/static/media/e4af272ccee01ff0-s.p.woff2",{"as":"font","type":"font/woff2"}]
2:HL["/_next/static/css/9152c37d2d6aee8c.css",{"as":"style"}]
0:[[["",{"children":["posts",{"children":[["slug","drcom","c"],{"children":["__PAGE__?{\"slug\":[\"drcom\"]}",{}]}]}]},"$undefined","$undefined",true],"$L3",[[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/9152c37d2d6aee8c.css","precedence":"next"}]],["$L4",["$","meta",null,{"name":"next-size-adjust"}]]]]]
5:I{"id":"394","chunks":["485:static/chunks/485-3071997949e00430.js","185:static/chunks/app/layout-0c716af5725e1bc4.js"],"name":"ThemeProvider","async":false}
6:I{"id":"7749","chunks":["485:static/chunks/485-3071997949e00430.js","185:static/chunks/app/layout-0c716af5725e1bc4.js"],"name":"ModeToggle","async":false}
7:I{"id":"6485","chunks":["485:static/chunks/485-3071997949e00430.js","931:static/chunks/app/page-e79f42fe7bcedc85.js"],"name":"","async":false}
8:I{"id":"5813","chunks":["272:static/chunks/webpack-3a35b39d748bae39.js","508:static/chunks/3949d24b-b3670977323a3ac7.js","604:static/chunks/604-576b6ce5c58b6c72.js"],"name":"","async":false}
9:I{"id":"8464","chunks":["272:static/chunks/webpack-3a35b39d748bae39.js","508:static/chunks/3949d24b-b3670977323a3ac7.js","604:static/chunks/604-576b6ce5c58b6c72.js"],"name":"","async":false}
b:I{"id":"8900","chunks":["485:static/chunks/485-3071997949e00430.js","185:static/chunks/app/layout-0c716af5725e1bc4.js"],"name":"Analytics","async":false}
3:[["$","html",null,{"lang":"en","children":["$","body",null,{"className":"antialiased min-h-screen bg-white dark:bg-slate-950 text-slate-900 dark:text-slate-50 __className_52d07b","children":["$","$L5",null,{"attribute":"class","defaultTheme":"system","enableSystem":true,"children":[["$","div",null,{"className":"max-w-2xl mx-auto py-10 px-4","children":[["$","header",null,{"children":["$","div",null,{"className":"flex items-center justify-between","children":[["$","$L6",null,{}],["$","nav",null,{"className":"ml-auto text-sm font-medium space-x-6","children":[["$","$L7",null,{"href":"/","children":"Home"}],["$","$L7",null,{"href":"/about","children":"About"}]]}]]}]}],["$","main",null,{"children":["$","$L8",null,{"parallelRouterKey":"children","segmentPath":["children"],"error":"$undefined","errorStyles":"$undefined","loading":"$undefined","loadingStyles":"$undefined","hasLoading":false,"template":["$","$L9",null,{}],"templateStyles":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined","asNotFound":"$undefined","childProp":{"current":["$","$L8",null,{"parallelRouterKey":"children","segmentPath":["children","posts","children"],"error":"$undefined","errorStyles":"$undefined","loading":"$undefined","loadingStyles":"$undefined","hasLoading":false,"template":["$","$L9",null,{}],"templateStyles":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined","asNotFound":"$undefined","childProp":{"current":["$","$L8",null,{"parallelRouterKey":"children","segmentPath":["children","posts","children",["slug","drcom","c"],"children"],"error":"$undefined","errorStyles":"$undefined","loading":"$undefined","loadingStyles":"$undefined","hasLoading":false,"template":["$","$L9",null,{}],"templateStyles":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined","asNotFound":"$undefined","childProp":{"current":["$La",null],"segment":"__PAGE__?{\"slug\":[\"drcom\"]}"},"styles":[]}],"segment":["slug","drcom","c"]},"styles":[]}],"segment":"posts"},"styles":[]}]}]]}],["$","$Lb",null,{}]]}]}]}],null]
4:[[["$","meta",null,{"charSet":"utf-8"}],["$","title",null,{"children":"在任意 OpenWrt 设备上运行 EasyDrcom"}],["$","meta",null,{"name":"description","content":"一块心病的解决 ❤️"}],null,null,null,null,null,null,null,null,["$","meta",null,{"name":"viewport","content":"width=device-width, initial-scale=1"}],null,null,null,null,null,null,null,null,null,null,[]],[null,null,null,null],null,null,[null,null,null,null,null],null,null,null,null,[null,[["$","link",null,{"rel":"icon","href":"/favicon.ico","type":"image/x-icon","sizes":"any"}]],[],null]]
a:["$","article",null,{"className":"py-6 prose dark:prose-invert","children":[["$","h1",null,{"className":"mb-2","children":"在任意 OpenWrt 设备上运行 EasyDrcom"}],["$","p",null,{"className":"text-xl mt-0 text-slate-700 dark:text-slate-200","children":"一块心病的解决 ❤️"}],["$","hr",null,{"className":"my-4"}],[["$","p",null,{"children":"“如何在任意刷写了 OpenWrt 的设备上运行 EasyDrcom” 一直是我的一个心病，因为大学期间搞了好多次，搞了好久，时间跨度将近两年也没解决这个问题。不过最近有时间，用了两天时间，终于研究得差不多了。"}],"\n",["$","p",null,{"children":"设备以 HG255D 为例"}],"\n",["$","p",null,{"children":"开发前要搭建 OpenWrt 交叉编译环境，按照网上教程就可以了，就是在 Ubuntu 上安装各种包。然后开始开发："}],"\n",["$","p",null,{"children":"1.下载对应芯片的 SDK，里面包含了开发一个 OpenWrt 软件包所需要的所有东西。\n比如 HG255D 是 rampis 厂家 rt3052 芯片，那么最新版 OpenWrt 对应的 SDK 链接就是 https://archive.openwrt.org/releases/21.02.0/targets/ramips/rt305x/openwrt-sdk-21.02.0-ramips-rt305x_gcc-8.4.0_musl.Linux-x86_64.tar.xz"}],"\n",["$","p",null,{"children":"OpenWrt 前几个版本差异有点大，而且还出了 LEDE 这样一个 fork，所以你路由里用的什么版本的固件，就要使用什么版本的 SDK，不然兼容性可能有问题。比如 21 的 SDK 编译的软件包在 14 的系统下很有可能是跑不了的。"}],"\n",["$","p",null,{"children":["2.解压 SDK，进入文件夹，首先要获取必要的包，运行 ",["$","code",null,{"children":"./script/feeds update -a"}],"，之后运行 ",["$","code",null,{"children":"./script/feeds install -af"}]," 这样就安装了所有的依赖。如果发生问题，要不是时区的问题，要么是梯子的问题，自行解决吧。"]}],"\n",["$","blockquote",null,{"children":["\n",["$","p",null,{"children":"其实有 docker 的话还能再简单一点：docker pull openwrtorg/sdk:ramips-rt305x-21.02.1"}],"\n"]}],"\n",["$","p",null,{"children":"3.在 package 目录下建立我们自己的包，首先建空文件夹命名为 easydrcom，然后创建一个 Makefile，内容如下："}],"\n",["$","pre",null,{"children":["$","code",null,{"className":"language-Makefile","children":"###############################################\n#OpenWrt Makefile for easydrcom program\n##############################################\ninclude $(TOPDIR)/rules.mk\n# Name and release number of this package\nPKG_NAME:=easydrcom\nPKG_RELEASE:=1\n# This specifies the directory where we're going to build the program.\n# The root build directory, $(BUILD_DIR), is by default the build_mipsel\n# directory in your OpenWrt SDK directory\nPKG_BUILD_DIR := $(BUILD_DIR)/$(PKG_NAME)\ninclude $(INCLUDE_DIR)/package.mk\n# Specify package information for this program.\n# The variables defined here should be self explanatory.\n# If you are running Kamikaze, delete the DESCRIPTION\n# variable below and uncomment the Kamikaze define\n# directive for the description below\ndefine Package/$(PKG_NAME)\n\tSECTION:=utils\n\tCATEGORY:=Utilities\n\tDEPENDS:=+libpcap +libpthread +libstdcpp\n\tTITLE:=$(PKG_NAME) -- drcom fro hitwh\nendef\n# Uncomment portion below for Kamikaze and delete DESCRIPTION variable above\ndefine Package/$(PKG_NAME)/description\n\tfree wireless at hitwh.\nendef\n# Specify what needs to be done to prepare for building the package.\n# In our case, we need to copy the source files to the build directory.\n# This is NOT the default.  The default uses the PKG_SOURCE_URL and the\n# PKG_SOURCE which is not defined here to download the source from the web.\n# In order to just build a simple program that we have just written, it is\n# much easier to do it this way.\ndefine Build/Prepare\n\tmkdir -p $(PKG_BUILD_DIR)\n\t$(CP) ./src/* $(PKG_BUILD_DIR)/\nendef\n# We do not need to define Build/Configure or Build/Compile directives\n# The defaults are appropriate for compiling a simple program such as this one\n# Specify where and how to install the program. Since we only have one file,\n# the easydrcom executable, install it by copying it to the /bin directory on\n# the router. The $(1) variable represents the root directory on the router running\n# OpenWrt. The $(INSTALL_DIR) variable contains a command to prepare the install\n# directory if it does not already exist.  Likewise $(INSTALL_BIN) contains the\n# command to copy the binary file from its current location (in our case the build\n# directory) to the install directory.\ndefine Package/$(PKG_NAME)/install\n\t$(INSTALL_DIR) $(1)/bin\n\t$(INSTALL_BIN) $(PKG_BUILD_DIR)/$(PKG_NAME) $(1)/bin/\nendef\n# This line executes the necessary commands to compile our program.\n# The above define directives specify all the information needed, but this\n# line calls BuildPackage which in turn actually uses this information to build a package.\n$(eval $(call BuildPackage,$(PKG_NAME)))\n"}]}],"\n",["$","p",null,{"children":"4.建立src文件夹，将 EasyDrcom 的代码复制进去，链接：https://github.com/coverxit/EasyDrcom/tree/master/EasyDrcom\n这里需要修改一下，我们不用 boost，一是太老了，二是编译时候还需要额外引入 boost，没必要这样。"}],"\n",["$","p",null,{"children":"我们使用这个头文件，用一个文件就能解析 init 配置文件：https://github.com/benhoyt/inih"}],"\n",["$","p",null,{"children":"复制 https://github.com/benhoyt/inih/tree/master/cpp 下 INIReader.h 到 src 文件夹里"}],"\n",["$","p",null,{"children":"5.修改 main.cpp 为"}],"\n",["$","pre",null,{"children":["$","code",null,{"className":"language-cpp","children":"/**\n * Copyright (C) 2014 Shindo\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include <thread>\n#include <mutex>\n#include <condition_variable>\n#include <chrono>\n\n#include <iostream>\n#include <string>\n#include <vector>\n#include <stdexcept>\n#include <functional>\n#include <ctime>\n#include <fstream>\n#include <sstream>\n#include <cctype>\n\n#if defined(__APPLE__) || defined(LINUX) || defined(linux)\n#include <sys/types.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <net/ethernet.h>\n#endif\n\n#include \"INIReader.h\"\n#include \"easy_drcom_exception.hpp\"\n\nstruct easy_drcom_config {\n    struct config_general {\n        int mode;\n        std::string username;\n        std::string password;\n        bool auto_online;\n        bool auto_redial;\n    } general;\n    \n    struct config_remote {\n        std::string ip;\n        uint32_t port;\n        \n        bool use_broadcast;\n        std::vector<uint8_t> mac;\n    } remote;\n    \n    struct config_local {\n        std::string nic;\n        std::string hostname;\n        std::string kernel_version;\n        \n        std::string ip;\n        std::vector<uint8_t> mac;\n        \n        uint32_t eap_timeout;\n        uint32_t udp_timeout;\n    } local;\n    \n    struct config_fake {\n        bool enable;\n        std::vector<uint8_t> mac;\n        std::string username;\n        std::string password;\n    } fake;\n} conf;\n\n// Log Config\n#define EASYDRCOM_DEBUG\n//#define EASYDRCOM_PRINT_DBG_ON_SCREEN\n#include \"log.hpp\"\n\n#define MAX_RETRY_TIME 2\n#include \"utils.hpp\"\n#include \"drcom_dealer.hpp\"\n#include \"eap_dealer.hpp\"\n\n#define VERSION \"v0.9\"\n\n#if defined (WIN32)\n#define VERSION (MAJOR_VERSION \" for Windows\")\n#elif defined __APPLE__\n#define VERSION (MAJOR_VERSION \" for Mac OSX\")\n#elif defined (OPENWRT)\n#define VERSION (MAJOR_VERSION \" for OpenWrt (mips AR7xxx/9xxx)\")\n#elif defined (LINUX)\n#define VERSION (MAJOR_VERSION \" for Linux\")\n#endif\n\nint read_config(std::string path)\n{\n    INIReader pt(path);\n\n    try {\n        conf.general.mode = pt.GetInteger(\"General\", \"Mode\", 0);\n        conf.general.username = pt.Get(\"General\", \"UserName\", \"\");\n        conf.general.password = pt.Get(\"General\", \"PassWord\", \"\");\n        conf.local.nic = pt.Get(\"Local\", \"NIC\", \"\");\n    }\n    catch (std::exception& e) {\n        SYS_LOG_ERR(\"Failed to read '\" << path << \"' - \" << e.what() << std::endl);\n        return EBADF;\n    }\n    \n    conf.general.auto_online = pt.GetBoolean(\"General\", \"AutoOnline\", true);\n    conf.general.auto_redial = pt.GetBoolean(\"General\", \"AutoRedial\", true);\n    \n    conf.remote.ip = pt.Get(\"Remote\", \"IP\", \"172.25.8.4\");\n    conf.remote.port = pt.GetBoolean(\"Remote\", \"Port\", 61440);\n    conf.remote.use_broadcast = pt.GetBoolean(\"Remote\", \"UseBroadcast\", true);\n    \n    if (!conf.remote.use_broadcast)\n        conf.remote.mac = str_mac_to_vec(pt.Get(\"Remote\",\"MAC\", \"00:1a:a9:c3:3a:59\"));\n    \n    conf.local.hostname = pt.Get(\"Local\", \"HostName\", \"EasyDrcom for HITwh\");\n    conf.local.kernel_version = pt.Get(\"Local\",\"KernelVersion\", \"0.7\");\n    \n    conf.local.eap_timeout = pt.GetInteger(\"Local\", \"EAPTimeout\", 1000);\n    conf.local.udp_timeout = pt.GetInteger(\"Local\", \"UDPTimeout\", 2000);\n    \n    conf.fake.enable = pt.GetInteger(\"Fake\", \"Enable\", 0);\n    \n    SYS_LOG_DBG(\"General.UserName = \" << conf.general.username << \", General.PassWord = \" << conf.general.password << \", General.Mode = \" << conf.general.mode << std::endl);\n    SYS_LOG_DBG(\"General.AutoOnline = \" << (conf.general.auto_online ? \"True\" : \"False\") << \", General.AutoRedial = \" << (conf.general.auto_redial ? \"True\" : \"False\" ) << std::endl);\n    SYS_LOG_DBG(\"Remote.IP:Port = \" << conf.remote.ip << \":\" << conf.remote.port << \", Remote.UseBroadcast = \" << (conf.remote.use_broadcast ? \"True\" : \"False\" ) << std::endl);\n    if (!conf.remote.use_broadcast) SYS_LOG_DBG(\"Remote.MAC = \" << hex_to_str(&conf.remote.mac[0], 6, ':') << std::endl);\n    SYS_LOG_DBG(\"Local.NIC = \" << conf.local.nic << \", Local.HostName = \" << conf.local.hostname << \", Local.KernelVersion = \" << conf.local.kernel_version << std::endl);\n    SYS_LOG_DBG(\"Local.EAPTimeout = \" << conf.local.eap_timeout << \", Local.UDPTimeout = \" << conf.local.udp_timeout << std::endl);\n    \n    try {\n        conf.local.ip = get_ip_address(conf.local.nic);\n        conf.local.mac = get_mac_address(conf.local.nic);\n        \n        SYS_LOG_INFO(\"Fetch NIC IP & MAC successfully.\" << std::endl);\n        SYS_LOG_INFO(\"Local.IP = \" << conf.local.ip << \", Local.MAC = \" << hex_to_str(&conf.local.mac[0], 6, ':') << std::endl);\n    }\n    catch (std::exception& e) {\n        SYS_LOG_ERR(\"Failed to fetch NIC info - \" << e.what() << std::endl);\n        return EBADF;\n    }\n    \n    if (conf.fake.enable) // fake user\n    {\n        try {\n            conf.fake.mac = str_mac_to_vec(pt.Get(\"Fake\", \"MAC\", \"\"));\n            conf.fake.username = pt.Get(\"Fake\", \"UserName\", \"\");\n            conf.fake.password = pt.Get(\"Fake\", \"PassWord\", \"\");\n        }\n        catch (std::exception& e) {\n            SYS_LOG_ERR(\"Failed to read fake settings - \" << e.what() << std::endl);\n            return EBADF;\n        }\n        \n        SYS_LOG_INFO(\"Fetch fake settings successfully.\" << std::endl);\n        SYS_LOG_INFO(\"Fake.MAC = \" << hex_to_str(&conf.fake.mac[0], 6, ':') << \", Fake.UserName = \" << conf.fake.username << \", Fake.PassWord = \" << conf.fake.password << std::endl);\n        \n    }\n    SYS_LOG_INFO(\"Loaded config successfully.\" << std::endl);\n    \n    return 0;\n}\n\nstd::shared_ptr<eap_dealer> eap;\nstd::shared_ptr<drcom_dealer_base> drcom;\n\nenum ONLINE_STATE\n{\n    OFFLINE_PROCESSING,\n    OFFLINE_NOTIFY,\n    OFFLINE,\n    ONLINE_PROCESSING,\n    ONLINE,\n};\nONLINE_STATE state = OFFLINE;\n\nstd::mutex mtx;\nstd::condition_variable cv;\n\nstd::vector<uint8_t> broadcast_mac = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };\nstd::vector<uint8_t> nearest_mac = { 0x01, 0x80, 0xc2, 0x00, 0x00, 0x03 };\n\nvoid online_func()\n{\n    do\n    {\n        try\n        {\n            do\n            {\n                state = ONLINE_PROCESSING;\n\t\t\t\ttry\n                {\n                    if (conf.general.mode != 1) // 宿舍区认证模式\n                    {\n                        if (conf.remote.use_broadcast)\n                        {\n                            eap->logoff(nearest_mac);\n                            eap->logoff(nearest_mac);\n                            \n                            if (eap->start(broadcast_mac)) break;\n                            if (eap->response_identity(broadcast_mac)) break;\n                            if (eap->response_md5_challenge(broadcast_mac)) break;\n                        }\n                        else\n                        {\n                            eap->logoff(conf.remote.mac);\n                            eap->logoff(conf.remote.mac);\n                            \n                            if (eap->start(conf.remote.mac)) break;\n                            if (eap->response_identity(conf.remote.mac)) break;\n                            if (eap->response_md5_challenge(conf.remote.mac)) break;\n                        }\n                    }\n                    \n                    if (conf.general.mode <= 1) // U31.R0\n                    {\n                        std::shared_ptr<drcom_dealer_u31> dealer = std::dynamic_pointer_cast<drcom_dealer_u31>(drcom);\n                        \n                        if (dealer->start_request()) break;\n                        if (dealer->send_login_auth()) break;\n                    }\n                    else // U62.R0\n                    {\n                        std::shared_ptr<drcom_dealer_u62> dealer = std::dynamic_pointer_cast<drcom_dealer_u62>(drcom);\n                    }\n                    \n                    while (true && state != OFFLINE_PROCESSING) // Keep Alive\n                    {\n                        try\n                        {\n                            if (conf.general.mode <= 1) // U31.R0\n                            {\n                                std::shared_ptr<drcom_dealer_u31> dealer = std::dynamic_pointer_cast<drcom_dealer_u31>(drcom);\n                                \n                                if (dealer->send_alive_request()) break;\n                                if (dealer->send_alive_pkt1()) break;\n                                if (dealer->send_alive_pkt2()) break;\n                            }\n                            else // U62.R0\n                            {\n                                std::shared_ptr<drcom_dealer_u62> dealer = std::dynamic_pointer_cast<drcom_dealer_u62>(drcom);\n                            \n                                if (dealer->send_alive_pkt1()) break;\n                                if (dealer->send_alive_pkt2()) break;\n                            }\n                            \n                            state = ONLINE;\n                            \n                            std::unique_lock<std::mutex> lock(mtx);\n                            cv.wait_for(lock, std::chrono::seconds(20));\n                        }\n                        catch (std::exception& e)\n                        {\n                            state = OFFLINE;\n                            SYS_LOG_ERR(\"Keep Alive: \" << e.what() << std::endl);\n                            break;\n                        }\n                    }\n                }\n\t\t\t\tcatch (std::exception& e)\n                {\n                    state = OFFLINE;\n                    SYS_LOG_ERR(\"Go Online: \" << e.what() << std::endl);\n                    break;\n                }\n                \n                if (state != OFFLINE_PROCESSING)\n                    state = OFFLINE;\n            }\n            while (false); // run once\n            \n            if (state != OFFLINE_PROCESSING)\n            {\n                SYS_LOG_INFO(\"Connection broken, try to redial after 5 seconds.\" << std::endl);\n                std::this_thread::sleep_for(std::chrono::seconds(5));\n            }\n        }\n        catch (std::exception& e)\n        {\n            SYS_LOG_ERR(\"Thread Online: \" << e.what() << std::endl);\n        }\n    } while (conf.general.auto_redial && state != OFFLINE_PROCESSING); // auto redial\n    \n    std::unique_lock<std::mutex> lock(mtx);\n    state = OFFLINE_NOTIFY;\n    cv.notify_one();\n}\n\nvoid offline_func()\n{\n    try\n    {\n        state = OFFLINE_PROCESSING;\n        \n        std::unique_lock<std::mutex> lock(mtx);\n        cv.notify_one();\n        \n        while (state != OFFLINE_NOTIFY)\n            cv.wait(lock); // wait for signal\n        \n        if (conf.general.mode <= 1) // U31.R0\n        {\n            std::shared_ptr<drcom_dealer_u31> dealer = std::dynamic_pointer_cast<drcom_dealer_u31>(drcom);\n            \n            dealer->send_alive_request();\n            dealer->start_request();\n            dealer->send_logout_auth();\n        }\n        // U62.R0 needn't do anything\n    }\n    catch (std::exception& e)\n    {\n        SYS_LOG_ERR(\"Go Offline: \" << e.what() << std::endl);\n    }\n    \n    if (conf.general.mode == 0 || conf.general.mode == 2) // 宿舍区\n    {\n        if (conf.remote.use_broadcast)\n        {\n            eap->logoff(broadcast_mac);\n            eap->logoff(nearest_mac);\n        }\n        else\n        {\n            eap->logoff(conf.remote.mac);\n        }\n    }\n\n    state = OFFLINE;\n    SYS_LOG_INFO(\"Offline.\" << std::endl);\n}\n\nint main(int argc, const char * argv[])\n{\n    int ret = 0;\n    bool background = false, redirect_to_null = false;\n    std::string config_path = \"EasyDrcom.conf\";\n    auto clog_def = std::clog.rdbuf();\n    auto cout_def = std::cout.rdbuf();\n    auto cerr_def = std::cerr.rdbuf();\n#ifdef OPENWRT\n    std::string log_path = \"/tmp/EasyDrcom.log\";\n#else\n    std::string log_path = \"EasyDrcom.log\";\n#endif\n    \n    for (int i = 1; i < argc; i++)\n    {\n        if (!strcmp(argv[i], \"-b\"))\n            background = true;\n        else if (!strcmp(argv[i], \"-r\"))\n            redirect_to_null = true;\n        else if (!strcmp(argv[i], \"-c\"))\n        {\n            if (i + 1 < argc)\n                config_path = argv[i+1];\n        }\n        else if (!strcmp(argv[i], \"-o\"))\n        {\n            if (i + 1 < argc)\n                log_path = argv[i+1];\n        }\n    }\n    \n    std::ofstream log(log_path);\n    if (!log.is_open())\n    {\n        std::cerr << \"[Error] Failed to open log '\" << log_path << \"', quitting...\" << std::endl;\n        return ENOENT;\n    }\n    std::clog.rdbuf(log.rdbuf());\n    \n    std::ofstream null(\"/dev/null\");\n    if (redirect_to_null)\n    {\n        std::cout.rdbuf(null.rdbuf());\n        std::cerr.rdbuf(null.rdbuf());\n    }\n    \n    SYS_LOG_INFO(\"EasyDrcom \" << VERSION << \" (build on \" << __DATE__ << \" \" << __TIME__ << \")\" << std::endl);\n    SYS_LOG_INFO(\"Code by Shindo, Contributors: mylight, SwimmingTiger.\" << std::endl << std::endl);\n    SYS_LOG_INFO(\"Initializing...\" << std::endl);\n    SYS_LOG_INFO(\"Loading config from '\" << config_path << \"'...\" << std::endl);\n    \n    // Initialization\n    if ((ret = read_config(config_path)) != 0)\n        goto end;\n    \n    \n#if defined(WIN32)\n\tWSADATA\twsa;\n\tWSAStartup(MAKEWORD(2, 2), &wsa);\n#endif\n    \n    try\n    {\n        eap = std::shared_ptr<eap_dealer>(new eap_dealer(conf.local.nic, conf.local.mac, conf.local.ip, conf.general.username, conf.general.password)); // the fucking \"Segmentation fault\", so we must have to use this line all the time!!!\n        \n        if (!conf.fake.enable)\n        {\n            if (conf.general.mode <= 1) // U31.R0\n                drcom = std::shared_ptr<drcom_dealer_base>(new drcom_dealer_u31(conf.local.mac, conf.local.ip, conf.general.username, conf.general.password, conf.remote.ip, conf.remote.port, conf.local.hostname, conf.local.kernel_version));\n            else // U62.R0\n                drcom = std::shared_ptr<drcom_dealer_base>(new drcom_dealer_u62(conf.local.mac, conf.local.ip, conf.general.username, conf.general.password, conf.remote.ip, conf.remote.port, conf.local.hostname, conf.local.kernel_version));\n        }\n        else\n        {\n            if (conf.general.mode <= 1) // U31.R0\n                drcom = std::shared_ptr<drcom_dealer_base>(new drcom_dealer_u31(conf.fake.mac, conf.local.ip, conf.fake.username, conf.fake.password, conf.remote.ip, conf.remote.port, conf.local.hostname, conf.local.kernel_version));\n            else // U62.R0\n                drcom = std::shared_ptr<drcom_dealer_base>(new drcom_dealer_u62(conf.fake.mac, conf.local.ip, conf.fake.username, conf.fake.password, conf.remote.ip, conf.remote.port, conf.local.hostname, conf.local.kernel_version));\n        }\n    }\n    catch (std::exception& e)\n    {\n        SYS_LOG_ERR(e.what() << std::endl);\n        ret = ENETRESET;\n        goto end;\n    }\n    \n    SYS_LOG_INFO(\"Initialization done!\" << std::endl);\n    \n    if (background)\n    {\n        SYS_LOG_INFO(\"Start in background, turn on Auto Online & Auto Redial.\" << std::endl);\n        conf.general.auto_online = true;\n        conf.general.auto_redial = true;\n    }\n    \n    if (!background)\n        SYS_LOG_INFO(\"Enter 'help' to get help.\" << std::endl);\n    \n    if (!conf.general.auto_online)\n    {\n        SYS_LOG_INFO(\"Enter 'online' to go online!\" << std::endl);\n    }\n    else\n    {\n        SYS_LOG_INFO(\"Going online...\" << std::endl);\n        std::thread(online_func).detach();\n    }\n    \n    if (background)\n    {\n        std::thread(online_func).join();\n    }\n    else\n    {\n        // Command Loop\n        std::string cmd;\n        while (true)\n        {\n            std::cin >> cmd;\n            if (!cmd.compare(\"online\"))\n            {\n                if (state == ONLINE)\n                {\n                    SYS_LOG_INFO(\"Already online!\" << std::endl);\n                }\n                else if (state == ONLINE_PROCESSING)\n                {\n                    SYS_LOG_INFO(\"Online Processing!\" << std::endl);\n                }\n                else if (state == OFFLINE_PROCESSING || state == OFFLINE_NOTIFY)\n                {\n                    SYS_LOG_INFO(\"Offline Processing!\" << std::endl);\n                }\n                else if (state == OFFLINE)\n                {\n                    SYS_LOG_INFO(\"Going online...\" << std::endl);\n                    std::thread(online_func).detach();\n                }\n            }\n            else if (!cmd.compare(\"offline\"))\n            {\n                if (state == OFFLINE)\n                {\n                    SYS_LOG_INFO(\"Haven't been online!\" << std::endl);\n                }\n                else if (state == ONLINE_PROCESSING)\n                {\n                    SYS_LOG_INFO(\"Online Processing!\" << std::endl);\n                }\n                else if (state == OFFLINE_PROCESSING)\n                {\n                    SYS_LOG_INFO(\"Offline Processing!\" << std::endl);\n                }\n                else if (state == ONLINE)\n                {\n                    SYS_LOG_INFO(\"Going offline...\" << std::endl);\n                    std::thread(offline_func).detach();\n                }\n            }\n            else if (!cmd.compare(\"quit\"))\n            {\n                if (state == ONLINE_PROCESSING)\n                {\n                    SYS_LOG_INFO(\"Please wait for online processing finished.\" << std::endl);\n                    continue;\n                }\n                \n                if (state == OFFLINE_PROCESSING)\n                {\n                    SYS_LOG_INFO(\"Please wait for offline processing finished.\" << std::endl);\n                    continue;\n                }\n                \n                if (state == ONLINE)\n                {\n                    SYS_LOG_INFO(\"Going offline...\" << std::endl);\n                    offline_func();\n                }\n                \n                SYS_LOG_INFO(\"Quitting...\" << std::endl);\n                std::cout << \"[EasyDrcom Info] Bye Bye!\" << std::endl;\n                break;\n            }\n            else if (!cmd.compare(\"help\"))\n            {\n                SYS_LOG_INFO(\"EasyDrcom \" << VERSION << \" (build on \" << __DATE__ << \" \" << __TIME__ << \")\" << std::endl);\n                SYS_LOG_INFO(\"Code by Shindo, Contributors: mylight, SwimmingTiger.\" << std::endl << std::endl);\n                SYS_LOG_INFO(\"Command list:\" << std::endl);\n                SYS_LOG_INFO(\"online - go online.\" << std::endl);\n                SYS_LOG_INFO(\"offline - go offline.\" << std::endl);\n                SYS_LOG_INFO(\"quit - quit EasyDrcom.\" << std::endl);\n            }\n            else\n            {\n                SYS_LOG_INFO(\"Wrong command: \" << cmd << std::endl);\n            }\n        }\n    }\n    \nend:\n    std::cout.rdbuf(cout_def);\n    std::cerr.rdbuf(cerr_def);\n    std::clog.rdbuf(clog_def);\n    \n    log.close();\n    null.close();\n    \n#if defined (WIN32)\n\tWSACleanup();\n#endif\n    return ret;\n}\n"}]}],"\n",["$","p",null,{"children":"6.最后在 src 目录下再建一个 Makefile："}],"\n",["$","pre",null,{"children":["$","code",null,{"className":"language-Makefile","children":"LIBS += -lpthread -lpcap -lstdc++\nLDFLAGS += -DLINUX -DOPENWRT\nCFLAGS += -Os\n\neasydrcom: main.o md5.o   \n\t$(CXX) $(LDFLAGS) main.o md5.o -o easydrcom $(LIBS)\nmd5.o: md5.c        \n\t$(CXX) $(CFLAGS) -c md5.c\nmain.o: main.cpp\n\t$(CXX) $(CFLAGS) -c main.cpp\nclean: \n\trm *.o\n\trm easydrcom\n"}]}],"\n",["$","p",null,{"children":["之后就开始编译，首先 ",["$","code",null,{"children":"make menuconfig"}]," 去掉不需要编译的包，然后 ",["$","code",null,{"children":"make package/easydrcom/compile -j8 V=s"}]," 八核编译，等一会就好了"]}],"\n",["$","p",null,{"children":["$","img",null,{"src":"https://user-images.githubusercontent.com/20496444/146671231-5c2c92eb-a81e-4b30-9bde-5cbcc6e81c22.png","alt":"opok"}]}],"\n",["$","p",null,{"children":["附件：\n",["$","a",null,{"href":"https://github.com/vanishcode/Blog/files/7701417/hg255d.zip","children":"hg255d.zip"}]]}]]]}]
