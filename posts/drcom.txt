1:HL["/_next/static/media/e4af272ccee01ff0-s.p.woff2",{"as":"font","type":"font/woff2"}]
2:HL["/_next/static/css/ab7e9e5ae5ed4b12.css",{"as":"style"}]
0:[[["",{"children":["posts",{"children":[["slug","drcom","c"],{"children":["__PAGE__?{\"slug\":[\"drcom\"]}",{}]}]}]},"$undefined","$undefined",true],"$L3",[[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/ab7e9e5ae5ed4b12.css","precedence":"next"}]],["$L4",["$","meta",null,{"name":"next-size-adjust"}]]]]]
5:I{"id":"394","chunks":["485:static/chunks/485-3071997949e00430.js","185:static/chunks/app/layout-7bad7b7e5ca4fdde.js"],"name":"ThemeProvider","async":false}
6:I{"id":"7749","chunks":["485:static/chunks/485-3071997949e00430.js","185:static/chunks/app/layout-7bad7b7e5ca4fdde.js"],"name":"ModeToggle","async":false}
7:I{"id":"6485","chunks":["485:static/chunks/485-3071997949e00430.js","931:static/chunks/app/page-0646269d36453bf0.js"],"name":"","async":false}
8:I{"id":"5813","chunks":["272:static/chunks/webpack-a86faf77022bc88e.js","508:static/chunks/3949d24b-b3670977323a3ac7.js","604:static/chunks/604-576b6ce5c58b6c72.js"],"name":"","async":false}
9:I{"id":"8464","chunks":["272:static/chunks/webpack-a86faf77022bc88e.js","508:static/chunks/3949d24b-b3670977323a3ac7.js","604:static/chunks/604-576b6ce5c58b6c72.js"],"name":"","async":false}
b:I{"id":"8900","chunks":["485:static/chunks/485-3071997949e00430.js","185:static/chunks/app/layout-7bad7b7e5ca4fdde.js"],"name":"Analytics","async":false}
3:[["$","html",null,{"lang":"en","children":["$","body",null,{"className":"antialiased min-h-screen bg-white dark:bg-slate-950 text-slate-900 dark:text-slate-50 __className_611a59","children":["$","$L5",null,{"attribute":"class","defaultTheme":"system","enableSystem":true,"children":[["$","div",null,{"className":"max-w-2xl mx-auto py-10 px-4","children":[["$","header",null,{"children":["$","div",null,{"className":"flex items-center justify-between","children":[["$","$L6",null,{}],["$","nav",null,{"className":"ml-auto text-sm font-medium space-x-6","children":[["$","$L7",null,{"href":"/","children":"Home ğŸ "}],["$","$L7",null,{"href":"/about","children":"About ğŸ¤“"}]]}]]}]}],["$","main",null,{"children":["$","$L8",null,{"parallelRouterKey":"children","segmentPath":["children"],"error":"$undefined","errorStyles":"$undefined","loading":"$undefined","loadingStyles":"$undefined","hasLoading":false,"template":["$","$L9",null,{}],"templateStyles":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined","asNotFound":"$undefined","childProp":{"current":["$","$L8",null,{"parallelRouterKey":"children","segmentPath":["children","posts","children"],"error":"$undefined","errorStyles":"$undefined","loading":"$undefined","loadingStyles":"$undefined","hasLoading":false,"template":["$","$L9",null,{}],"templateStyles":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined","asNotFound":"$undefined","childProp":{"current":["$","$L8",null,{"parallelRouterKey":"children","segmentPath":["children","posts","children",["slug","drcom","c"],"children"],"error":"$undefined","errorStyles":"$undefined","loading":"$undefined","loadingStyles":"$undefined","hasLoading":false,"template":["$","$L9",null,{}],"templateStyles":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined","asNotFound":"$undefined","childProp":{"current":["$La",null],"segment":"__PAGE__?{\"slug\":[\"drcom\"]}"},"styles":[]}],"segment":["slug","drcom","c"]},"styles":[]}],"segment":"posts"},"styles":[]}]}]]}],["$","$Lb",null,{}]]}]}]}],null]
4:[[["$","meta",null,{"charSet":"utf-8"}],["$","title",null,{"children":"åœ¨ä»»æ„ OpenWrt è®¾å¤‡ä¸Šè¿è¡Œ EasyDrcom"}],["$","meta",null,{"name":"description","content":"ä¸€å—å¿ƒç—…çš„è§£å†³ â¤ï¸"}],null,null,null,null,null,null,null,null,["$","meta",null,{"name":"viewport","content":"width=device-width, initial-scale=1"}],null,null,null,null,null,null,null,null,null,null,[]],[null,null,null,null],null,null,[null,null,null,null,null],null,null,null,null,[null,[["$","link",null,{"rel":"icon","href":"/favicon.ico","type":"image/x-icon","sizes":"any"}]],[],null]]
a:["$","article",null,{"className":"py-6 prose dark:prose-invert","children":[["$","h1",null,{"className":"mb-2","children":"åœ¨ä»»æ„ OpenWrt è®¾å¤‡ä¸Šè¿è¡Œ EasyDrcom"}],["$","p",null,{"className":"text-xl mt-0 text-slate-700 dark:text-slate-200","children":"ä¸€å—å¿ƒç—…çš„è§£å†³ â¤ï¸"}],["$","hr",null,{"className":"my-4"}],[["$","p",null,{"children":"â€œå¦‚ä½•åœ¨ä»»æ„åˆ·å†™äº† OpenWrt çš„è®¾å¤‡ä¸Šè¿è¡Œ EasyDrcomâ€ ä¸€ç›´æ˜¯æˆ‘çš„ä¸€ä¸ªå¿ƒç—…ï¼Œå› ä¸ºå¤§å­¦æœŸé—´æäº†å¥½å¤šæ¬¡ï¼Œæäº†å¥½ä¹…ï¼Œæ—¶é—´è·¨åº¦å°†è¿‘ä¸¤å¹´ä¹Ÿæ²¡è§£å†³è¿™ä¸ªé—®é¢˜ã€‚ä¸è¿‡æœ€è¿‘æœ‰æ—¶é—´ï¼Œç”¨äº†ä¸¤å¤©æ—¶é—´ï¼Œç»ˆäºç ”ç©¶å¾—å·®ä¸å¤šäº†ã€‚"}],"\n",["$","p",null,{"children":"è®¾å¤‡ä»¥ HG255D ä¸ºä¾‹"}],"\n",["$","p",null,{"children":"å¼€å‘å‰è¦æ­å»º OpenWrt äº¤å‰ç¼–è¯‘ç¯å¢ƒï¼ŒæŒ‰ç…§ç½‘ä¸Šæ•™ç¨‹å°±å¯ä»¥äº†ï¼Œå°±æ˜¯åœ¨ Ubuntu ä¸Šå®‰è£…å„ç§åŒ…ã€‚ç„¶åå¼€å§‹å¼€å‘ï¼š"}],"\n",["$","p",null,{"children":"1.ä¸‹è½½å¯¹åº”èŠ¯ç‰‡çš„ SDKï¼Œé‡Œé¢åŒ…å«äº†å¼€å‘ä¸€ä¸ª OpenWrt è½¯ä»¶åŒ…æ‰€éœ€è¦çš„æ‰€æœ‰ä¸œè¥¿ã€‚\næ¯”å¦‚ HG255D æ˜¯ rampis å‚å®¶ rt3052 èŠ¯ç‰‡ï¼Œé‚£ä¹ˆæœ€æ–°ç‰ˆ OpenWrt å¯¹åº”çš„ SDK é“¾æ¥å°±æ˜¯ https://archive.openwrt.org/releases/21.02.0/targets/ramips/rt305x/openwrt-sdk-21.02.0-ramips-rt305x_gcc-8.4.0_musl.Linux-x86_64.tar.xz"}],"\n",["$","p",null,{"children":"OpenWrt å‰å‡ ä¸ªç‰ˆæœ¬å·®å¼‚æœ‰ç‚¹å¤§ï¼Œè€Œä¸”è¿˜å‡ºäº† LEDE è¿™æ ·ä¸€ä¸ª forkï¼Œæ‰€ä»¥ä½ è·¯ç”±é‡Œç”¨çš„ä»€ä¹ˆç‰ˆæœ¬çš„å›ºä»¶ï¼Œå°±è¦ä½¿ç”¨ä»€ä¹ˆç‰ˆæœ¬çš„ SDKï¼Œä¸ç„¶å…¼å®¹æ€§å¯èƒ½æœ‰é—®é¢˜ã€‚æ¯”å¦‚ 21 çš„ SDK ç¼–è¯‘çš„è½¯ä»¶åŒ…åœ¨ 14 çš„ç³»ç»Ÿä¸‹å¾ˆæœ‰å¯èƒ½æ˜¯è·‘ä¸äº†çš„ã€‚"}],"\n",["$","p",null,{"children":["2.è§£å‹ SDKï¼Œè¿›å…¥æ–‡ä»¶å¤¹ï¼Œé¦–å…ˆè¦è·å–å¿…è¦çš„åŒ…ï¼Œè¿è¡Œ ",["$","code",null,{"children":"./script/feeds update -a"}],"ï¼Œä¹‹åè¿è¡Œ ",["$","code",null,{"children":"./script/feeds install -af"}]," è¿™æ ·å°±å®‰è£…äº†æ‰€æœ‰çš„ä¾èµ–ã€‚å¦‚æœå‘ç”Ÿé—®é¢˜ï¼Œè¦ä¸æ˜¯æ—¶åŒºçš„é—®é¢˜ï¼Œè¦ä¹ˆæ˜¯æ¢¯å­çš„é—®é¢˜ï¼Œè‡ªè¡Œè§£å†³å§ã€‚"]}],"\n",["$","blockquote",null,{"children":["\n",["$","p",null,{"children":"å…¶å®æœ‰ docker çš„è¯è¿˜èƒ½å†ç®€å•ä¸€ç‚¹ï¼šdocker pull openwrtorg/sdk:ramips-rt305x-21.02.1"}],"\n"]}],"\n",["$","p",null,{"children":"3.åœ¨ package ç›®å½•ä¸‹å»ºç«‹æˆ‘ä»¬è‡ªå·±çš„åŒ…ï¼Œé¦–å…ˆå»ºç©ºæ–‡ä»¶å¤¹å‘½åä¸º easydrcomï¼Œç„¶ååˆ›å»ºä¸€ä¸ª Makefileï¼Œå†…å®¹å¦‚ä¸‹ï¼š"}],"\n",["$","pre",null,{"children":["$","code",null,{"className":"language-Makefile","children":"###############################################\n#OpenWrt Makefile for easydrcom program\n##############################################\ninclude $(TOPDIR)/rules.mk\n# Name and release number of this package\nPKG_NAME:=easydrcom\nPKG_RELEASE:=1\n# This specifies the directory where we're going to build the program.\n# The root build directory, $(BUILD_DIR), is by default the build_mipsel\n# directory in your OpenWrt SDK directory\nPKG_BUILD_DIR := $(BUILD_DIR)/$(PKG_NAME)\ninclude $(INCLUDE_DIR)/package.mk\n# Specify package information for this program.\n# The variables defined here should be self explanatory.\n# If you are running Kamikaze, delete the DESCRIPTION\n# variable below and uncomment the Kamikaze define\n# directive for the description below\ndefine Package/$(PKG_NAME)\n\tSECTION:=utils\n\tCATEGORY:=Utilities\n\tDEPENDS:=+libpcap +libpthread +libstdcpp\n\tTITLE:=$(PKG_NAME) -- drcom fro hitwh\nendef\n# Uncomment portion below for Kamikaze and delete DESCRIPTION variable above\ndefine Package/$(PKG_NAME)/description\n\tfree wireless at hitwh.\nendef\n# Specify what needs to be done to prepare for building the package.\n# In our case, we need to copy the source files to the build directory.\n# This is NOT the default.  The default uses the PKG_SOURCE_URL and the\n# PKG_SOURCE which is not defined here to download the source from the web.\n# In order to just build a simple program that we have just written, it is\n# much easier to do it this way.\ndefine Build/Prepare\n\tmkdir -p $(PKG_BUILD_DIR)\n\t$(CP) ./src/* $(PKG_BUILD_DIR)/\nendef\n# We do not need to define Build/Configure or Build/Compile directives\n# The defaults are appropriate for compiling a simple program such as this one\n# Specify where and how to install the program. Since we only have one file,\n# the easydrcom executable, install it by copying it to the /bin directory on\n# the router. The $(1) variable represents the root directory on the router running\n# OpenWrt. The $(INSTALL_DIR) variable contains a command to prepare the install\n# directory if it does not already exist.  Likewise $(INSTALL_BIN) contains the\n# command to copy the binary file from its current location (in our case the build\n# directory) to the install directory.\ndefine Package/$(PKG_NAME)/install\n\t$(INSTALL_DIR) $(1)/bin\n\t$(INSTALL_BIN) $(PKG_BUILD_DIR)/$(PKG_NAME) $(1)/bin/\nendef\n# This line executes the necessary commands to compile our program.\n# The above define directives specify all the information needed, but this\n# line calls BuildPackage which in turn actually uses this information to build a package.\n$(eval $(call BuildPackage,$(PKG_NAME)))\n"}]}],"\n",["$","p",null,{"children":"4.å»ºç«‹srcæ–‡ä»¶å¤¹ï¼Œå°† EasyDrcom çš„ä»£ç å¤åˆ¶è¿›å»ï¼Œé“¾æ¥ï¼šhttps://github.com/coverxit/EasyDrcom/tree/master/EasyDrcom\nè¿™é‡Œéœ€è¦ä¿®æ”¹ä¸€ä¸‹ï¼Œæˆ‘ä»¬ä¸ç”¨ boostï¼Œä¸€æ˜¯å¤ªè€äº†ï¼ŒäºŒæ˜¯ç¼–è¯‘æ—¶å€™è¿˜éœ€è¦é¢å¤–å¼•å…¥ boostï¼Œæ²¡å¿…è¦è¿™æ ·ã€‚"}],"\n",["$","p",null,{"children":"æˆ‘ä»¬ä½¿ç”¨è¿™ä¸ªå¤´æ–‡ä»¶ï¼Œç”¨ä¸€ä¸ªæ–‡ä»¶å°±èƒ½è§£æ init é…ç½®æ–‡ä»¶ï¼šhttps://github.com/benhoyt/inih"}],"\n",["$","p",null,{"children":"å¤åˆ¶ https://github.com/benhoyt/inih/tree/master/cpp ä¸‹ INIReader.h åˆ° src æ–‡ä»¶å¤¹é‡Œ"}],"\n",["$","p",null,{"children":"5.ä¿®æ”¹ main.cpp ä¸º"}],"\n",["$","pre",null,{"children":["$","code",null,{"className":"language-cpp","children":"/**\n * Copyright (C) 2014 Shindo\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include <thread>\n#include <mutex>\n#include <condition_variable>\n#include <chrono>\n\n#include <iostream>\n#include <string>\n#include <vector>\n#include <stdexcept>\n#include <functional>\n#include <ctime>\n#include <fstream>\n#include <sstream>\n#include <cctype>\n\n#if defined(__APPLE__) || defined(LINUX) || defined(linux)\n#include <sys/types.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <net/ethernet.h>\n#endif\n\n#include \"INIReader.h\"\n#include \"easy_drcom_exception.hpp\"\n\nstruct easy_drcom_config {\n    struct config_general {\n        int mode;\n        std::string username;\n        std::string password;\n        bool auto_online;\n        bool auto_redial;\n    } general;\n    \n    struct config_remote {\n        std::string ip;\n        uint32_t port;\n        \n        bool use_broadcast;\n        std::vector<uint8_t> mac;\n    } remote;\n    \n    struct config_local {\n        std::string nic;\n        std::string hostname;\n        std::string kernel_version;\n        \n        std::string ip;\n        std::vector<uint8_t> mac;\n        \n        uint32_t eap_timeout;\n        uint32_t udp_timeout;\n    } local;\n    \n    struct config_fake {\n        bool enable;\n        std::vector<uint8_t> mac;\n        std::string username;\n        std::string password;\n    } fake;\n} conf;\n\n// Log Config\n#define EASYDRCOM_DEBUG\n//#define EASYDRCOM_PRINT_DBG_ON_SCREEN\n#include \"log.hpp\"\n\n#define MAX_RETRY_TIME 2\n#include \"utils.hpp\"\n#include \"drcom_dealer.hpp\"\n#include \"eap_dealer.hpp\"\n\n#define VERSION \"v0.9\"\n\n#if defined (WIN32)\n#define VERSION (MAJOR_VERSION \" for Windows\")\n#elif defined __APPLE__\n#define VERSION (MAJOR_VERSION \" for Mac OSX\")\n#elif defined (OPENWRT)\n#define VERSION (MAJOR_VERSION \" for OpenWrt (mips AR7xxx/9xxx)\")\n#elif defined (LINUX)\n#define VERSION (MAJOR_VERSION \" for Linux\")\n#endif\n\nint read_config(std::string path)\n{\n    INIReader pt(path);\n\n    try {\n        conf.general.mode = pt.GetInteger(\"General\", \"Mode\", 0);\n        conf.general.username = pt.Get(\"General\", \"UserName\", \"\");\n        conf.general.password = pt.Get(\"General\", \"PassWord\", \"\");\n        conf.local.nic = pt.Get(\"Local\", \"NIC\", \"\");\n    }\n    catch (std::exception& e) {\n        SYS_LOG_ERR(\"Failed to read '\" << path << \"' - \" << e.what() << std::endl);\n        return EBADF;\n    }\n    \n    conf.general.auto_online = pt.GetBoolean(\"General\", \"AutoOnline\", true);\n    conf.general.auto_redial = pt.GetBoolean(\"General\", \"AutoRedial\", true);\n    \n    conf.remote.ip = pt.Get(\"Remote\", \"IP\", \"172.25.8.4\");\n    conf.remote.port = pt.GetBoolean(\"Remote\", \"Port\", 61440);\n    conf.remote.use_broadcast = pt.GetBoolean(\"Remote\", \"UseBroadcast\", true);\n    \n    if (!conf.remote.use_broadcast)\n        conf.remote.mac = str_mac_to_vec(pt.Get(\"Remote\",\"MAC\", \"00:1a:a9:c3:3a:59\"));\n    \n    conf.local.hostname = pt.Get(\"Local\", \"HostName\", \"EasyDrcom for HITwh\");\n    conf.local.kernel_version = pt.Get(\"Local\",\"KernelVersion\", \"0.7\");\n    \n    conf.local.eap_timeout = pt.GetInteger(\"Local\", \"EAPTimeout\", 1000);\n    conf.local.udp_timeout = pt.GetInteger(\"Local\", \"UDPTimeout\", 2000);\n    \n    conf.fake.enable = pt.GetInteger(\"Fake\", \"Enable\", 0);\n    \n    SYS_LOG_DBG(\"General.UserName = \" << conf.general.username << \", General.PassWord = \" << conf.general.password << \", General.Mode = \" << conf.general.mode << std::endl);\n    SYS_LOG_DBG(\"General.AutoOnline = \" << (conf.general.auto_online ? \"True\" : \"False\") << \", General.AutoRedial = \" << (conf.general.auto_redial ? \"True\" : \"False\" ) << std::endl);\n    SYS_LOG_DBG(\"Remote.IP:Port = \" << conf.remote.ip << \":\" << conf.remote.port << \", Remote.UseBroadcast = \" << (conf.remote.use_broadcast ? \"True\" : \"False\" ) << std::endl);\n    if (!conf.remote.use_broadcast) SYS_LOG_DBG(\"Remote.MAC = \" << hex_to_str(&conf.remote.mac[0], 6, ':') << std::endl);\n    SYS_LOG_DBG(\"Local.NIC = \" << conf.local.nic << \", Local.HostName = \" << conf.local.hostname << \", Local.KernelVersion = \" << conf.local.kernel_version << std::endl);\n    SYS_LOG_DBG(\"Local.EAPTimeout = \" << conf.local.eap_timeout << \", Local.UDPTimeout = \" << conf.local.udp_timeout << std::endl);\n    \n    try {\n        conf.local.ip = get_ip_address(conf.local.nic);\n        conf.local.mac = get_mac_address(conf.local.nic);\n        \n        SYS_LOG_INFO(\"Fetch NIC IP & MAC successfully.\" << std::endl);\n        SYS_LOG_INFO(\"Local.IP = \" << conf.local.ip << \", Local.MAC = \" << hex_to_str(&conf.local.mac[0], 6, ':') << std::endl);\n    }\n    catch (std::exception& e) {\n        SYS_LOG_ERR(\"Failed to fetch NIC info - \" << e.what() << std::endl);\n        return EBADF;\n    }\n    \n    if (conf.fake.enable) // fake user\n    {\n        try {\n            conf.fake.mac = str_mac_to_vec(pt.Get(\"Fake\", \"MAC\", \"\"));\n            conf.fake.username = pt.Get(\"Fake\", \"UserName\", \"\");\n            conf.fake.password = pt.Get(\"Fake\", \"PassWord\", \"\");\n        }\n        catch (std::exception& e) {\n            SYS_LOG_ERR(\"Failed to read fake settings - \" << e.what() << std::endl);\n            return EBADF;\n        }\n        \n        SYS_LOG_INFO(\"Fetch fake settings successfully.\" << std::endl);\n        SYS_LOG_INFO(\"Fake.MAC = \" << hex_to_str(&conf.fake.mac[0], 6, ':') << \", Fake.UserName = \" << conf.fake.username << \", Fake.PassWord = \" << conf.fake.password << std::endl);\n        \n    }\n    SYS_LOG_INFO(\"Loaded config successfully.\" << std::endl);\n    \n    return 0;\n}\n\nstd::shared_ptr<eap_dealer> eap;\nstd::shared_ptr<drcom_dealer_base> drcom;\n\nenum ONLINE_STATE\n{\n    OFFLINE_PROCESSING,\n    OFFLINE_NOTIFY,\n    OFFLINE,\n    ONLINE_PROCESSING,\n    ONLINE,\n};\nONLINE_STATE state = OFFLINE;\n\nstd::mutex mtx;\nstd::condition_variable cv;\n\nstd::vector<uint8_t> broadcast_mac = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };\nstd::vector<uint8_t> nearest_mac = { 0x01, 0x80, 0xc2, 0x00, 0x00, 0x03 };\n\nvoid online_func()\n{\n    do\n    {\n        try\n        {\n            do\n            {\n                state = ONLINE_PROCESSING;\n\t\t\t\ttry\n                {\n                    if (conf.general.mode != 1) // å®¿èˆåŒºè®¤è¯æ¨¡å¼\n                    {\n                        if (conf.remote.use_broadcast)\n                        {\n                            eap->logoff(nearest_mac);\n                            eap->logoff(nearest_mac);\n                            \n                            if (eap->start(broadcast_mac)) break;\n                            if (eap->response_identity(broadcast_mac)) break;\n                            if (eap->response_md5_challenge(broadcast_mac)) break;\n                        }\n                        else\n                        {\n                            eap->logoff(conf.remote.mac);\n                            eap->logoff(conf.remote.mac);\n                            \n                            if (eap->start(conf.remote.mac)) break;\n                            if (eap->response_identity(conf.remote.mac)) break;\n                            if (eap->response_md5_challenge(conf.remote.mac)) break;\n                        }\n                    }\n                    \n                    if (conf.general.mode <= 1) // U31.R0\n                    {\n                        std::shared_ptr<drcom_dealer_u31> dealer = std::dynamic_pointer_cast<drcom_dealer_u31>(drcom);\n                        \n                        if (dealer->start_request()) break;\n                        if (dealer->send_login_auth()) break;\n                    }\n                    else // U62.R0\n                    {\n                        std::shared_ptr<drcom_dealer_u62> dealer = std::dynamic_pointer_cast<drcom_dealer_u62>(drcom);\n                    }\n                    \n                    while (true && state != OFFLINE_PROCESSING) // Keep Alive\n                    {\n                        try\n                        {\n                            if (conf.general.mode <= 1) // U31.R0\n                            {\n                                std::shared_ptr<drcom_dealer_u31> dealer = std::dynamic_pointer_cast<drcom_dealer_u31>(drcom);\n                                \n                                if (dealer->send_alive_request()) break;\n                                if (dealer->send_alive_pkt1()) break;\n                                if (dealer->send_alive_pkt2()) break;\n                            }\n                            else // U62.R0\n                            {\n                                std::shared_ptr<drcom_dealer_u62> dealer = std::dynamic_pointer_cast<drcom_dealer_u62>(drcom);\n                            \n                                if (dealer->send_alive_pkt1()) break;\n                                if (dealer->send_alive_pkt2()) break;\n                            }\n                            \n                            state = ONLINE;\n                            \n                            std::unique_lock<std::mutex> lock(mtx);\n                            cv.wait_for(lock, std::chrono::seconds(20));\n                        }\n                        catch (std::exception& e)\n                        {\n                            state = OFFLINE;\n                            SYS_LOG_ERR(\"Keep Alive: \" << e.what() << std::endl);\n                            break;\n                        }\n                    }\n                }\n\t\t\t\tcatch (std::exception& e)\n                {\n                    state = OFFLINE;\n                    SYS_LOG_ERR(\"Go Online: \" << e.what() << std::endl);\n                    break;\n                }\n                \n                if (state != OFFLINE_PROCESSING)\n                    state = OFFLINE;\n            }\n            while (false); // run once\n            \n            if (state != OFFLINE_PROCESSING)\n            {\n                SYS_LOG_INFO(\"Connection broken, try to redial after 5 seconds.\" << std::endl);\n                std::this_thread::sleep_for(std::chrono::seconds(5));\n            }\n        }\n        catch (std::exception& e)\n        {\n            SYS_LOG_ERR(\"Thread Online: \" << e.what() << std::endl);\n        }\n    } while (conf.general.auto_redial && state != OFFLINE_PROCESSING); // auto redial\n    \n    std::unique_lock<std::mutex> lock(mtx);\n    state = OFFLINE_NOTIFY;\n    cv.notify_one();\n}\n\nvoid offline_func()\n{\n    try\n    {\n        state = OFFLINE_PROCESSING;\n        \n        std::unique_lock<std::mutex> lock(mtx);\n        cv.notify_one();\n        \n        while (state != OFFLINE_NOTIFY)\n            cv.wait(lock); // wait for signal\n        \n        if (conf.general.mode <= 1) // U31.R0\n        {\n            std::shared_ptr<drcom_dealer_u31> dealer = std::dynamic_pointer_cast<drcom_dealer_u31>(drcom);\n            \n            dealer->send_alive_request();\n            dealer->start_request();\n            dealer->send_logout_auth();\n        }\n        // U62.R0 needn't do anything\n    }\n    catch (std::exception& e)\n    {\n        SYS_LOG_ERR(\"Go Offline: \" << e.what() << std::endl);\n    }\n    \n    if (conf.general.mode == 0 || conf.general.mode == 2) // å®¿èˆåŒº\n    {\n        if (conf.remote.use_broadcast)\n        {\n            eap->logoff(broadcast_mac);\n            eap->logoff(nearest_mac);\n        }\n        else\n        {\n            eap->logoff(conf.remote.mac);\n        }\n    }\n\n    state = OFFLINE;\n    SYS_LOG_INFO(\"Offline.\" << std::endl);\n}\n\nint main(int argc, const char * argv[])\n{\n    int ret = 0;\n    bool background = false, redirect_to_null = false;\n    std::string config_path = \"EasyDrcom.conf\";\n    auto clog_def = std::clog.rdbuf();\n    auto cout_def = std::cout.rdbuf();\n    auto cerr_def = std::cerr.rdbuf();\n#ifdef OPENWRT\n    std::string log_path = \"/tmp/EasyDrcom.log\";\n#else\n    std::string log_path = \"EasyDrcom.log\";\n#endif\n    \n    for (int i = 1; i < argc; i++)\n    {\n        if (!strcmp(argv[i], \"-b\"))\n            background = true;\n        else if (!strcmp(argv[i], \"-r\"))\n            redirect_to_null = true;\n        else if (!strcmp(argv[i], \"-c\"))\n        {\n            if (i + 1 < argc)\n                config_path = argv[i+1];\n        }\n        else if (!strcmp(argv[i], \"-o\"))\n        {\n            if (i + 1 < argc)\n                log_path = argv[i+1];\n        }\n    }\n    \n    std::ofstream log(log_path);\n    if (!log.is_open())\n    {\n        std::cerr << \"[Error] Failed to open log '\" << log_path << \"', quitting...\" << std::endl;\n        return ENOENT;\n    }\n    std::clog.rdbuf(log.rdbuf());\n    \n    std::ofstream null(\"/dev/null\");\n    if (redirect_to_null)\n    {\n        std::cout.rdbuf(null.rdbuf());\n        std::cerr.rdbuf(null.rdbuf());\n    }\n    \n    SYS_LOG_INFO(\"EasyDrcom \" << VERSION << \" (build on \" << __DATE__ << \" \" << __TIME__ << \")\" << std::endl);\n    SYS_LOG_INFO(\"Code by Shindo, Contributors: mylight, SwimmingTiger.\" << std::endl << std::endl);\n    SYS_LOG_INFO(\"Initializing...\" << std::endl);\n    SYS_LOG_INFO(\"Loading config from '\" << config_path << \"'...\" << std::endl);\n    \n    // Initialization\n    if ((ret = read_config(config_path)) != 0)\n        goto end;\n    \n    \n#if defined(WIN32)\n\tWSADATA\twsa;\n\tWSAStartup(MAKEWORD(2, 2), &wsa);\n#endif\n    \n    try\n    {\n        eap = std::shared_ptr<eap_dealer>(new eap_dealer(conf.local.nic, conf.local.mac, conf.local.ip, conf.general.username, conf.general.password)); // the fucking \"Segmentation fault\", so we must have to use this line all the time!!!\n        \n        if (!conf.fake.enable)\n        {\n            if (conf.general.mode <= 1) // U31.R0\n                drcom = std::shared_ptr<drcom_dealer_base>(new drcom_dealer_u31(conf.local.mac, conf.local.ip, conf.general.username, conf.general.password, conf.remote.ip, conf.remote.port, conf.local.hostname, conf.local.kernel_version));\n            else // U62.R0\n                drcom = std::shared_ptr<drcom_dealer_base>(new drcom_dealer_u62(conf.local.mac, conf.local.ip, conf.general.username, conf.general.password, conf.remote.ip, conf.remote.port, conf.local.hostname, conf.local.kernel_version));\n        }\n        else\n        {\n            if (conf.general.mode <= 1) // U31.R0\n                drcom = std::shared_ptr<drcom_dealer_base>(new drcom_dealer_u31(conf.fake.mac, conf.local.ip, conf.fake.username, conf.fake.password, conf.remote.ip, conf.remote.port, conf.local.hostname, conf.local.kernel_version));\n            else // U62.R0\n                drcom = std::shared_ptr<drcom_dealer_base>(new drcom_dealer_u62(conf.fake.mac, conf.local.ip, conf.fake.username, conf.fake.password, conf.remote.ip, conf.remote.port, conf.local.hostname, conf.local.kernel_version));\n        }\n    }\n    catch (std::exception& e)\n    {\n        SYS_LOG_ERR(e.what() << std::endl);\n        ret = ENETRESET;\n        goto end;\n    }\n    \n    SYS_LOG_INFO(\"Initialization done!\" << std::endl);\n    \n    if (background)\n    {\n        SYS_LOG_INFO(\"Start in background, turn on Auto Online & Auto Redial.\" << std::endl);\n        conf.general.auto_online = true;\n        conf.general.auto_redial = true;\n    }\n    \n    if (!background)\n        SYS_LOG_INFO(\"Enter 'help' to get help.\" << std::endl);\n    \n    if (!conf.general.auto_online)\n    {\n        SYS_LOG_INFO(\"Enter 'online' to go online!\" << std::endl);\n    }\n    else\n    {\n        SYS_LOG_INFO(\"Going online...\" << std::endl);\n        std::thread(online_func).detach();\n    }\n    \n    if (background)\n    {\n        std::thread(online_func).join();\n    }\n    else\n    {\n        // Command Loop\n        std::string cmd;\n        while (true)\n        {\n            std::cin >> cmd;\n            if (!cmd.compare(\"online\"))\n            {\n                if (state == ONLINE)\n                {\n                    SYS_LOG_INFO(\"Already online!\" << std::endl);\n                }\n                else if (state == ONLINE_PROCESSING)\n                {\n                    SYS_LOG_INFO(\"Online Processing!\" << std::endl);\n                }\n                else if (state == OFFLINE_PROCESSING || state == OFFLINE_NOTIFY)\n                {\n                    SYS_LOG_INFO(\"Offline Processing!\" << std::endl);\n                }\n                else if (state == OFFLINE)\n                {\n                    SYS_LOG_INFO(\"Going online...\" << std::endl);\n                    std::thread(online_func).detach();\n                }\n            }\n            else if (!cmd.compare(\"offline\"))\n            {\n                if (state == OFFLINE)\n                {\n                    SYS_LOG_INFO(\"Haven't been online!\" << std::endl);\n                }\n                else if (state == ONLINE_PROCESSING)\n                {\n                    SYS_LOG_INFO(\"Online Processing!\" << std::endl);\n                }\n                else if (state == OFFLINE_PROCESSING)\n                {\n                    SYS_LOG_INFO(\"Offline Processing!\" << std::endl);\n                }\n                else if (state == ONLINE)\n                {\n                    SYS_LOG_INFO(\"Going offline...\" << std::endl);\n                    std::thread(offline_func).detach();\n                }\n            }\n            else if (!cmd.compare(\"quit\"))\n            {\n                if (state == ONLINE_PROCESSING)\n                {\n                    SYS_LOG_INFO(\"Please wait for online processing finished.\" << std::endl);\n                    continue;\n                }\n                \n                if (state == OFFLINE_PROCESSING)\n                {\n                    SYS_LOG_INFO(\"Please wait for offline processing finished.\" << std::endl);\n                    continue;\n                }\n                \n                if (state == ONLINE)\n                {\n                    SYS_LOG_INFO(\"Going offline...\" << std::endl);\n                    offline_func();\n                }\n                \n                SYS_LOG_INFO(\"Quitting...\" << std::endl);\n                std::cout << \"[EasyDrcom Info] Bye Bye!\" << std::endl;\n                break;\n            }\n            else if (!cmd.compare(\"help\"))\n            {\n                SYS_LOG_INFO(\"EasyDrcom \" << VERSION << \" (build on \" << __DATE__ << \" \" << __TIME__ << \")\" << std::endl);\n                SYS_LOG_INFO(\"Code by Shindo, Contributors: mylight, SwimmingTiger.\" << std::endl << std::endl);\n                SYS_LOG_INFO(\"Command list:\" << std::endl);\n                SYS_LOG_INFO(\"online - go online.\" << std::endl);\n                SYS_LOG_INFO(\"offline - go offline.\" << std::endl);\n                SYS_LOG_INFO(\"quit - quit EasyDrcom.\" << std::endl);\n            }\n            else\n            {\n                SYS_LOG_INFO(\"Wrong command: \" << cmd << std::endl);\n            }\n        }\n    }\n    \nend:\n    std::cout.rdbuf(cout_def);\n    std::cerr.rdbuf(cerr_def);\n    std::clog.rdbuf(clog_def);\n    \n    log.close();\n    null.close();\n    \n#if defined (WIN32)\n\tWSACleanup();\n#endif\n    return ret;\n}\n"}]}],"\n",["$","p",null,{"children":"6.æœ€ååœ¨ src ç›®å½•ä¸‹å†å»ºä¸€ä¸ª Makefileï¼š"}],"\n",["$","pre",null,{"children":["$","code",null,{"className":"language-Makefile","children":"LIBS += -lpthread -lpcap -lstdc++\nLDFLAGS += -DLINUX -DOPENWRT\nCFLAGS += -Os\n\neasydrcom: main.o md5.o   \n\t$(CXX) $(LDFLAGS) main.o md5.o -o easydrcom $(LIBS)\nmd5.o: md5.c        \n\t$(CXX) $(CFLAGS) -c md5.c\nmain.o: main.cpp\n\t$(CXX) $(CFLAGS) -c main.cpp\nclean: \n\trm *.o\n\trm easydrcom\n"}]}],"\n",["$","p",null,{"children":["ä¹‹åå°±å¼€å§‹ç¼–è¯‘ï¼Œé¦–å…ˆ ",["$","code",null,{"children":"make menuconfig"}]," å»æ‰ä¸éœ€è¦ç¼–è¯‘çš„åŒ…ï¼Œç„¶å ",["$","code",null,{"children":"make package/easydrcom/compile -j8 V=s"}]," å…«æ ¸ç¼–è¯‘ï¼Œç­‰ä¸€ä¼šå°±å¥½äº†"]}],"\n",["$","p",null,{"children":["$","img",null,{"src":"https://user-images.githubusercontent.com/20496444/146671231-5c2c92eb-a81e-4b30-9bde-5cbcc6e81c22.png","alt":"opok"}]}],"\n",["$","p",null,{"children":["é™„ä»¶ï¼š\n",["$","a",null,{"href":"https://github.com/vanishcode/Blog/files/7701417/hg255d.zip","children":"hg255d.zip"}]]}]]]}]
